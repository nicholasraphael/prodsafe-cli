Apple_PubSub_Socket_Render=/private/tmp/com.apple.launchd.pKy0yWl3og/Render
BASH=/bin/bash
BASH_ARGC=()
BASH_ARGV=()
BASH_LINENO=()
BASH_REMATCH=([0]="e")
BASH_SOURCE=()
BASH_VERSINFO=([0]="3" [1]="2" [2]="57" [3]="1" [4]="release" [5]="x86_64-apple-darwin16")
BASH_VERSION='3.2.57(1)-release'
COLUMNS=212
DIRSTACK=()
EUID=501
GEM_HOME=/Users/nicholasraphael/.rvm/gems/ruby-2.4.2
GEM_PATH=/Users/nicholasraphael/.rvm/gems/ruby-2.4.2:/Users/nicholasraphael/.rvm/gems/ruby-2.4.2@global
GOPATH=/Users/nicholasraphael/go
GROUPS=()
HISTFILE=/Users/nicholasraphael/.bash_sessions/FEE736BF-8688-482E-9A52-95E436EC6717.historynew
HISTFILESIZE=500
HISTSIZE=500
HOME=/Users/nicholasraphael
HOSTNAME=Nicholass-MBP.attlocal.net
HOSTTYPE=x86_64
IFS=$' \t\n'
IRBRC=/Users/nicholasraphael/.rvm/rubies/ruby-2.4.2/.irbrc
LANG=en_US.UTF-8
LINES=61
LOGNAME=nicholasraphael
MACHTYPE=x86_64-apple-darwin16
MAILCHECK=60
MY_RUBY_HOME=/Users/nicholasraphael/.rvm/rubies/ruby-2.4.2
OLDPWD=/Users/nicholasraphael/Desktop/prodsafe-app/prodsafe/cmds
OPTERR=1
OPTIND=1
OSTYPE=darwin16
PATH='/Users/nicholasraphael/google-cloud-sdk/bin:/Users/nicholasraphael/.rvm/gems/ruby-2.4.2/bin:/Users/nicholasraphael/.rvm/gems/ruby-2.4.2@global/bin:/Users/nicholasraphael/.rvm/rubies/ruby-2.4.2/bin:/Users/nicholasraphael/anaconda/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/share/dotnet:~/.dotnet/tools:/Library/Frameworks/Mono.framework/Versions/Current/Commands:/Applications/Postgres.app/Contents/Versions/latest/bin:/Users/nicholasraphael/.rvm/bin:/Users/nicholasraphael/go/bin:/Users/nicholasraphael/torch/install/bin'
PGDATABASE=encloud-test
PGHOST=localhost
PGPASSWORD=hillview
PGPORT=5432
PGUSER=postgres
PIPESTATUS=([0]="130")
PPID=91908
PROMPT_COMMAND=update_terminal_cwd
PS1='\h:\W \u\$ '
PS2='> '
PS4='+ '
PWD=/Users/nicholasraphael/Desktop/prodsafe-app/prodsafe
RUBY_VERSION=ruby-2.4.2
SECURITYSESSIONID=18b6d
SHELL=/bin/bash
SHELLOPTS=braceexpand:emacs:hashall:histexpand:history:interactive-comments:monitor
SHELL_SESSION_DID_HISTORY_CHECK=1
SHELL_SESSION_DID_INIT=1
SHELL_SESSION_DIR=/Users/nicholasraphael/.bash_sessions
SHELL_SESSION_FILE=/Users/nicholasraphael/.bash_sessions/FEE736BF-8688-482E-9A52-95E436EC6717.session
SHELL_SESSION_HISTFILE=/Users/nicholasraphael/.bash_sessions/FEE736BF-8688-482E-9A52-95E436EC6717.history
SHELL_SESSION_HISTFILE_NEW=/Users/nicholasraphael/.bash_sessions/FEE736BF-8688-482E-9A52-95E436EC6717.historynew
SHELL_SESSION_HISTFILE_SHARED=/Users/nicholasraphael/.bash_history
SHELL_SESSION_HISTORY=1
SHELL_SESSION_TIMESTAMP_FILE=/Users/nicholasraphael/.bash_sessions/_expiration_check_timestamp
SHLVL=1
SSH_AUTH_SOCK=/private/tmp/com.apple.launchd.lLQf9uQ9NM/Listeners
TERM=xterm-256color
TERM_PROGRAM=Apple_Terminal
TERM_PROGRAM_VERSION=388.1.3
TERM_SESSION_ID=FEE736BF-8688-482E-9A52-95E436EC6717
TMPDIR=/var/folders/jq/rjg7qt3s3711wz8v5hbqlpc40000gn/T/
UID=501
USER=nicholasraphael
XPC_FLAGS=0x0
XPC_SERVICE_NAME=0
_=postgresql
__CF_USER_TEXT_ENCODING=0x1F5:0x0:0x0
_system_arch=x86_64
_system_info='Darwin Nicholass-MBP.attlocal.net 16.7.0 Darwin Kernel Version 16.7.0: Wed Feb 27 00:29:57 PST 2019; root:xnu-3789.73.43~1/RELEASE_X86_64 x86_64'
_system_name=OSX
_system_name_lowercase=osx
_system_type=Darwin
_system_version=10.12
apparent_sdk_dir=/Users/nicholasraphael/google-cloud-sdk
bin_path=/Users/nicholasraphael/google-cloud-sdk/bin
chpwd_functions=([0]="__rvm_cd_functions_set")
entry=list
rvm_bin_path=/Users/nicholasraphael/.rvm/bin
rvm_ignore_rvmrc=0
rvm_path=/Users/nicholasraphael/.rvm
rvm_prefix=/Users/nicholasraphael
rvm_rubygems_path=/Users/nicholasraphael/.rvm/rubygems
rvm_saved_env=()
rvm_version='1.29.3 (latest)'
rvmrc=/Users/nicholasraphael/.rvmrc
script=override_gem
script_link=/Users/nicholasraphael/google-cloud-sdk/path.bash.inc
sdk_dir=/Users/nicholasraphael/google-cloud-sdk
__function_on_stack () 
{ 
    __rvm_string_includes "${FUNCNAME[*]}" "$@" || return $?
}
__function_unset () 
{ 
    if [[ -n "${ZSH_VERSION:-}" ]]; then
        unset -f "$1";
    else
        unset "$1";
    fi
}
__list_remote_all () 
{ 
    \typeset _iterator rvm_remote_server_url rvm_remote_server_path;
    _iterator="";
    while __rvm_db "rvm_remote_server_url${_iterator:-}" rvm_remote_server_url; do
        __rvm_include_travis_binaries || continue;
        __rvm_system_path "" "${_iterator}";
        rvm_debug "__list_remote_all${_iterator:-} $rvm_remote_server_url $rvm_remote_server_path";
        __list_remote_for "${rvm_remote_server_url}" "$rvm_remote_server_path";
        : $(( _iterator+=1 ));
    done | \command \sort -u | __rvm_version_sort
}
__list_remote_for () 
{ 
    __list_remote_for_local "$@" || __list_remote_for_index "$@" || __list_remote_for_s3 "$@" || return $?
}
__list_remote_for_index () 
{ 
    if file_exists_at_url "${1}/index.txt"; then
        rvm_debug "__list_remote_for_index ${1}/index.txt";
        __rvm_curl -s "${1}/index.txt" | GREP_OPTIONS="" \command \grep -E "${1}/${2}/.*\.tar\.(gz|bz2)$";
    else
        if file_exists_at_url "${1}/${2}/index.txt"; then
            rvm_debug "__list_remote_for_index ${1}/${2}/index.txt";
            __rvm_curl -s "${1}/${2}/index.txt" | GREP_OPTIONS="" \command \grep -E "${1}/${2}/.*\.tar\.(gz|bz2)$";
        else
            return 1;
        fi;
    fi;
    true
}
__list_remote_for_local () 
{ 
    \typeset __status1 __status2;
    __status1=0;
    __status2=0;
    if [[ -f $rvm_user_path/remote ]]; then
        __rvm_grep "${1}/${2}" < $rvm_user_path/remote || __status1=$?;
    fi;
    __rvm_grep "${1}/${2}" < $rvm_path/config/remote || __status2=$?;
    if (( __status1 || __status2 )); then
        return 1;
    else
        rvm_debug "__list_remote_for_local found";
    fi;
    true
}
__list_remote_for_s3 () 
{ 
    curl -ILfs "${1}" | __rvm_grep "Server: AmazonS3" > /dev/null || return $?;
    \typeset __tmp_name __iterator __next __local_url;
    __iterator=0;
    __next="";
    __tmp_name="$(
    : ${TMPDIR:=${rvm_tmp_path:-/tmp}}
    mktemp "${TMPDIR}/tmp.XXXXXXXXXXXXXXXXXX"
  )";
    while [[ __iterator -eq 0 || -n "${__next}" ]]; do
        __local_url="${1}?prefix=${2}/${__next:+&marker=${__next}}";
        rvm_debug "__list_remote_for_s3-${__iterator} ${__local_url}";
        __rvm_curl -s "${__local_url}" > "${__tmp_name}${__iterator}";
        GREP_OPTIONS="" \command \grep -oE "<Key>[^<]*</Key>" < "${__tmp_name}${__iterator}" | __rvm_awk -F"[<>]" '{print $3}' > "${__tmp_name}";
        if __rvm_grep "<IsTruncated>true</IsTruncated>" < "${__tmp_name}${__iterator}"; then
            __next="$(__rvm_tail -n 1 "${__tmp_name}")";
        else
            __next="";
        fi;
        rm "${__tmp_name}${__iterator}";
        : $(( __iterator+=1 ));
    done;
    GREP_OPTIONS="" \command \grep -E "${2}/.*\.tar\.(gz|bz2)$" < "${__tmp_name}" | GREP_OPTIONS="" \command \grep -v -- "-src-" | __rvm_awk "{ print "'"'$1/'"'"\$1 }";
    rm "${__tmp_name}"*
}
__rvm_add_once () 
{ 
    \typeset IFS;
    IFS="|";
    eval "[[ \"${IFS}\${${1}[*]}${IFS}\" == \*\"${IFS}\${2}${IFS}\"\* ]] || ${1}+=( \"\${2}\" )"
}
__rvm_add_to_path () 
{ 
    export PATH;
    if (( $# != 2 )) || [[ -z "$2" ]]; then
        rvm_error "__rvm_add_to_path requires two parameters";
        return 1;
    fi;
    __rvm_remove_from_path "$2";
    case "$1" in 
        prepend)
            PATH="$2:$PATH"
        ;;
        append)
            PATH="$PATH:$2"
        ;;
    esac;
    if [[ -n "${rvm_user_path_prefix:-}" ]]; then
        __rvm_remove_from_path "${rvm_user_path_prefix}";
        PATH="${rvm_user_path_prefix}:$PATH";
    fi;
    builtin hash -r
}
__rvm_after_cd () 
{ 
    \typeset rvm_hook;
    rvm_hook="after_cd";
    if [[ -n "${rvm_scripts_path:-}" || -n "${rvm_path:-}" ]]; then
        source "${rvm_scripts_path:-$rvm_path/scripts}/hook";
    fi
}
__rvm_ant () 
{ 
    \ant "$@" || return $?
}
__rvm_array_add_or_update () 
{ 
    \typeset _array_name _variable _separator _value _local_value;
    \typeset -a _array_value_old _array_value_new;
    _array_name="$1";
    _variable="$2";
    _separator="$3";
    _value="${4##${_separator}}";
    _array_value_new=();
    eval "_array_value_old=( \"\${${_array_name}[@]}\" )";
    case " ${_array_value_old[*]} " in 
        *[[:space:]]${_variable}*)
            for _local_value in "${_array_value_old[@]}";
            do
                case "${_local_value}" in 
                    ${_variable}*)
                        _array_value_new+=("${_local_value}${_separator}${_value}")
                    ;;
                    *)
                        _array_value_new+=("${_local_value}")
                    ;;
                esac;
            done
        ;;
        *)
            _array_value_new=("${_array_value_old[@]}" "${_variable}${_value}")
        ;;
    esac;
    eval "${_array_name}=( \"\${_array_value_new[@]}\" )"
}
__rvm_array_contains () 
{ 
    \typeset _search _iterator;
    _search="$1";
    shift;
    for _iterator in "$@";
    do
        case "${_iterator}" in 
            ${_search})
                return 0
            ;;
        esac;
    done;
    return 1
}
__rvm_array_prepend_or_ignore () 
{ 
    \typeset _array_name _variable _separator _value _prefix _local_value;
    \typeset -a _array_value_old _array_value_new;
    _array_name="$1";
    _variable="$2";
    _separator="$3";
    _value="$4";
    _prefix="$5";
    _array_value_new=();
    eval "_array_value_old=( \"\${${_array_name}[@]}\" )";
    case " ${_array_value_old[*]} " in 
        *[[:space:]]${_variable}*)
            for _local_value in "${_array_value_old[@]}";
            do
                case "${_local_value}" in 
                    ${_variable}*${_prefix}*)
                        rvm_debug "__rvm_array_prepend_or_ignore ${_array_name} ${_local_value}";
                        _array_value_new+=("${_local_value}")
                    ;;
                    ${_variable}*)
                        rvm_debug "__rvm_array_prepend_or_ignore ${_array_name} ${_variable}\"${_value}${_separator}${_local_value#${_variable}}\"";
                        _array_value_new+=("${_variable}${_value}${_separator}${_local_value#${_variable}}")
                    ;;
                    *)
                        _array_value_new+=("${_local_value}")
                    ;;
                esac;
            done;
            eval "${_array_name}=( \"\${_array_value_new[@]}\" )"
        ;;
    esac
}
__rvm_ask_for () 
{ 
    \typeset response;
    rvm_warn "$1";
    printf "%b" "(anything other than '$2' will cancel) > ";
    if read response && [[ "$2" == "$response" ]]; then
        return 0;
    else
        return 1;
    fi
}
__rvm_ask_to_trust () 
{ 
    \typeset trusted value anykey _rvmrc _rvmrc_base;
    _rvmrc="${1}";
    _rvmrc_base="$(basename "${_rvmrc}")";
    if [[ ! -t 0 || -n "$MC_SID" ]] || (( ${rvm_promptless:=0} == 1 )); then
        return 2;
    fi;
    __rvm_file_notice_initial;
    trusted=0;
    while (( ! trusted )); do
        printf "%b" 'y[es], n[o], v[iew], c[ancel]> ';
        builtin read response;
        value="$(echo -n "${response}" | \command \tr '[[:upper:]]' '[[:lower:]]' | __rvm_strip)";
        case "${value:-n}" in 
            v | view)
                __rvm_display_rvmrc
            ;;
            y | yes)
                trusted=1
            ;;
            n | no)
                break
            ;;
            c | cancel)
                return 1
            ;;
        esac;
    done;
    if (( trusted )); then
        __rvm_trust_rvmrc "$1";
        return 0;
    else
        __rvm_untrust_rvmrc "$1";
        return 1;
    fi
}
__rvm_automake () 
{ 
    \automake "$@" || return $?
}
__rvm_autoreconf () 
{ 
    \autoreconf "$@" || return $?
}
__rvm_awk () 
{ 
    \awk "$@" || return $?
}
__rvm_become () 
{ 
    \typeset string rvm_rvmrc_flag;
    string="$1";
    rvm_rvmrc_flag=0;
    [[ -n "$string" ]] && { 
        rvm_ruby_string="$string";
        rvm_gemset_name=""
    };
    __rvm_use > /dev/null || return $?;
    rvm_ruby_string="${rvm_ruby_string}${rvm_gemset_name:+${rvm_gemset_separator:-'@'}}${rvm_gemset_name:-}";
    return 0
}
__rvm_calculate_remote_file () 
{ 
    rvm_remote_server_url="$( __rvm_db "rvm_remote_server_url${3:-}" )";
    [[ -n "$rvm_remote_server_url" ]] || { 
        rvm_debug "rvm_remote_server_url${3:-} not found";
        return $1
    };
    __rvm_include_travis_binaries || return $1;
    __rvm_system_path "" "${3:-}";
    __rvm_ruby_package_file "${4:-}";
    __remote_file="${rvm_remote_server_url}/${rvm_remote_server_path}${rvm_ruby_package_file}"
}
__rvm_calculate_space_free () 
{ 
    __free_space="$( \command \df -Pk "$1" | __rvm_awk 'BEGIN{x=4} /Free/{x=3} $3=="Avail"{x=3} END{print $x}' )";
    if [[ "${__free_space}" == *M ]]; then
        __free_space="${__free_space%M}";
    else
        __free_space="$(( __free_space / 1024 ))";
    fi
}
__rvm_calculate_space_used () 
{ 
    __used_space="$( \command \du -msc "$@" | __rvm_awk 'END {print $1}' )";
    __used_space="${__used_space%M}"
}
__rvm_call_with_restored_umask () 
{ 
    rvm_umask="$(umask)";
    if [[ -n "${rvm_stored_umask:-}" ]]; then
        umask ${rvm_stored_umask};
    fi;
    "$@";
    umask "${rvm_umask}";
    unset rvm_umask
}
__rvm_cd () 
{ 
    \typeset old_cdpath ret;
    ret=0;
    old_cdpath="${CDPATH}";
    CDPATH=".";
    chpwd_functions="" builtin cd "$@" || ret=$?;
    CDPATH="${old_cdpath}";
    return $ret
}
__rvm_cd_functions_set () 
{ 
    __rvm_do_with_env_before;
    if [[ -n "${rvm_current_rvmrc:-""}" && "$OLDPWD" == "$PWD" ]]; then
        rvm_current_rvmrc="";
    fi;
    __rvm_project_rvmrc 1>&2 || true;
    __rvm_after_cd || true;
    __rvm_do_with_env_after;
    return 0
}
__rvm_check_pipestatus () 
{ 
    for __iterator in "$@";
    do
        case "${__iterator}" in 
            "")
                true
            ;;
            0)
                true
            ;;
            *)
                return ${__iterator}
            ;;
        esac;
    done;
    return 0
}
__rvm_check_rvmrc_trustworthiness () 
{ 
    (( ${rvm_trust_rvmrcs_flag:-0} == 0 )) || return 0;
    [[ -n "$1" ]] || (( $# > 1 )) || return 1;
    \typeset _first _second saveIFS;
    if [[ -n "${ZSH_VERSION:-}" ]]; then
        _first=1;
    else
        _first=0;
    fi;
    _second=$(( _first + 1 ));
    saveIFS="$IFS";
    IFS=';';
    \typeset -a trust;
    trust=($( __rvm_rvmrc_stored_trust "$1" ));
    IFS="$saveIFS";
    if [[ "${trust[${_second}]:-'#'}" == "$(__rvm_checksum_for_contents "$1")" ]]; then
        [[ "${trust[${_first}]}" == '1' ]] || return $?;
    else
        __rvm_ask_to_trust "$@" || return $?;
    fi;
    true
}
__rvm_checksum_all () 
{ 
    [[ -n "${_checksum_md5:-}" && -n "${_checksum_sha512:-}" ]]
}
__rvm_checksum_any () 
{ 
    [[ -n "${_checksum_md5:-}" || -n "${_checksum_sha512:-}" ]]
}
__rvm_checksum_calculate_file () 
{ 
    rvm_debug "Calculate checksums for file ${1}";
    _checksum_md5="$(    __rvm_md5_calculate      "${1:-}" )";
    _checksum_sha512="$( __rvm_sha__calculate 512 "${1:-}" )"
}
__rvm_checksum_for_contents () 
{ 
    \typeset __sum;
    __sum=$(  echo "$1" | \command \cat - "$1" | __rvm_md5_for_contents   ) || { 
        rvm_error "Neither md5 nor md5sum were found in the PATH";
        return 1
    };
    __sum+=$( echo "$1" | \command \cat - "$1" | __rvm_sha256_for_contents ) || { 
        rvm_error "Neither sha256sum nor shasum found in the PATH";
        return 1
    };
    echo ${__sum}
}
__rvm_checksum_none () 
{ 
    [[ -z "${_checksum_md5:-}" && -z "${_checksum_sha512:-}" ]]
}
__rvm_checksum_read () 
{ 
    rvm_debug "Load checksums for $1";
    __rvm_checksum_none || return 0;
    \typeset _type _value _name;
    \typeset -a _list;
    list=();
    for _name in "$@";
    do
        list+=("$_name");
        if [[ "$_name" == *"?"* ]]; then
            list+=("${_name%\?*}");
        fi;
    done;
    for _name in "${list[@]}";
    do
        _checksum_md5="$(      __rvm_db_ "$rvm_path/config/md5"    "$_name" | \command \head -n 1 )";
        [[ -n "${_checksum_md5:-}" ]] || _checksum_md5="$(    __rvm_db_ "$rvm_user_path/md5"      "$_name" | \command \head -n 1 )";
        _checksum_sha512="$(   __rvm_db_ "$rvm_path/config/sha512" "$_name" | \command \head -n 1 )";
        [[ -n "${_checksum_sha512:-}" ]] || _checksum_sha512="$( __rvm_db_ "$rvm_user_path/sha512"   "$_name" | \command \head -n 1 )";
        __rvm_checksum_none || return 0;
    done;
    rvm_debug "    ...checksums not found";
    return 1
}
__rvm_checksum_validate_file () 
{ 
    rvm_debug "Validating checksums for file ${1}";
    if __rvm_checksum_any; then
        rvm_debug "    ...checksums found in db";
    else
        rvm_debug "    ...checksums not found in db";
        return 1;
    fi;
    if [[ -n "${_checksum_md5:-}" ]]; then
        rvm_debug "Validating md5 checksum";
        if [[ "$(__rvm_md5_calculate "${1:-}")" == "${_checksum_md5:-}" ]]; then
            rvm_debug "    ...md5 checksum is valid!";
        else
            rvm_debug "    ...md5 checksum is not valid!!!";
            return 2;
        fi;
    fi;
    if [[ -n "${_checksum_sha512:-}" ]]; then
        rvm_debug "Validating sha15 checksum";
        if [[ "$(__rvm_sha__calculate 512 "${1:-}")" == "${_checksum_sha512:-}" ]]; then
            rvm_debug "    ...sha512 checksum is valid!";
        else
            rvm_debug "    ...sha512 checksum is not valid!!!";
            return 3;
        fi;
    fi;
    return 0
}
__rvm_checksum_write () 
{ 
    [[ -n "${1:-}" ]] || return 1;
    __rvm_checksum_any || return 1;
    [[ -z "${_checksum_md5:-}" ]] || __rvm_db_ "$rvm_user_path/md5" "${1:-}" "${_checksum_md5:-}";
    [[ -z "${_checksum_sha512:-}" ]] || __rvm_db_ "$rvm_user_path/sha512" "${1:-}" "${_checksum_sha512:-}";
    return 0
}
__rvm_cleanse_variables () 
{ 
    __rvm_unset_ruby_variables;
    if [[ ${rvm_sticky_flag:-0} -eq 1 ]]; then
        export rvm_gemset_name;
    else
        unset rvm_gemset_name;
    fi;
    unset rvm_configure_flags rvm_patch_names rvm_make_flags;
    unset rvm_env_string rvm_ruby_string rvm_action rvm_error_message rvm_force_flag rvm_debug_flag rvm_delete_flag rvm_summary_flag rvm_json_flag rvm_yaml_flag rvm_file_name rvm_user_flag rvm_system_flag rvm_install_flag rvm_llvm_flag rvm_sticky_flag rvm_rvmrc_flag rvm_gems_flag rvm_docs_flag rvm_ruby_alias rvm_static_flag rvm_archive_extension rvm_hook rvm_ruby_name rvm_remote_flag;
    __rvm_load_rvmrc
}
__rvm_cleanup_tmp () 
{ 
    if [[ -d "${rvm_tmp_path}/" ]]; then
        case "${rvm_tmp_path%\/}" in 
            *tmp)
                __rvm_rm_rf "${rvm_tmp_path}/${1:-$$}*"
            ;;
        esac;
    fi;
    true
}
__rvm_cli_autoreload () 
{ 
    if [[ ${rvm_reload_flag:-0} -eq 1 ]]; then
        if [[ -s "$rvm_scripts_path/rvm" ]]; then
            __rvm_project_rvmrc_lock=0;
            source "$rvm_scripts_path/rvm";
        else
            echo "rvm not found in $rvm_path, please install and run 'rvm reload'";
            __rvm_teardown;
        fi;
    else
        __rvm_teardown;
    fi
}
__rvm_cli_autoupdate () 
{ 
    [[ " $* " == *" install "* && " $* " != *" help install "* ]] || [[ " $* " == *" list known "* ]] || return 0;
    \typeset online_version version_release;
    case "${rvm_autoupdate_flag:-1}" in 
        0 | disabled)
            true
        ;;
        1 | warn)
            if __rvm_cli_autoupdate_version_old; then
                __rvm_cli_autoupdate_warning;
            fi
        ;;
        2 | enabled)
            if __rvm_cli_autoupdate_version_old; then
                __rvm_cli_autoupdate_execute || return $?;
            fi
        ;;
    esac;
    true
}
__rvm_cli_autoupdate_execute () 
{ 
    printf "%b" "Found old RVM ${rvm_version%% *} - updating.\n";
    __rvm_cli_rvm_get "${version_release}" || return $?;
    __rvm_cli_rvm_reload
}
__rvm_cli_autoupdate_version_old () 
{ 
    online_version="$( __rvm_version_remote )";
    version_release="$(\command \cat "$rvm_path/RELEASE" 2>/dev/null)";
    : version_release:"${version_release:=master}";
    [[ -s "$rvm_path/VERSION" && -n "${online_version:-}" && "${rvm_version%% *}" != "${online_version:-}" ]] || return $?
}
__rvm_cli_autoupdate_warning () 
{ 
    printf "%b" "Warning, new version of rvm available '${online_version}', you are using older version '${rvm_version%% *}'.
You can disable this warning with:    echo rvm_autoupdate_flag=0 >> ~/.rvmrc
You can enable  auto-update  with:    echo rvm_autoupdate_flag=2 >> ~/.rvmrc
"
}
__rvm_cli_get_and_execute_installer () 
{ 
    __rvm_cli_get_installer_cleanup || return $?;
    rvm_log "Downloading https://get.rvm.io";
    __rvm_curl -s https://get.rvm.io -o "${rvm_archives_path}/rvm-installer" || { 
        \typeset _ret=$?;
        rvm_error "Could not download rvm-installer, please report to https://github.com/rvm/rvm/issues";
        return ${_ret}
    };
    __rvm_cli_get_and_verify_pgp || return $?;
    bash "${rvm_archives_path}/rvm-installer" "$@" || { 
        \typeset _ret=$?;
        rvm_error "Could not update RVM, please report to https://github.com/rvm/rvm/issues";
        return ${_ret}
    }
}
__rvm_cli_get_and_verify_pgp () 
{ 
    \typeset rvm_gpg_command;
    if rvm_install_gpg_setup; then
        pgp_signature_url="$( __rvm_curl -sSI https://get.rvm.io | \tr "\r" " " | __rvm_awk '/Location:/{print $2".asc"}' )";
        rvm_log "Downloading $pgp_signature_url";
        __rvm_curl -s "${pgp_signature_url}" -o "${rvm_archives_path}/rvm-installer.asc" || return $?;
        rvm_log "Verifying ${rvm_archives_path}/rvm-installer.asc";
        verify_package_pgp "${rvm_archives_path}/rvm-installer" "${rvm_archives_path}/rvm-installer.asc" "$pgp_signature_url" || return $?;
    else
        rvm_warn "No GPG software exists to validate rvm-installer, skipping.";
    fi
}
__rvm_cli_get_installer_cleanup () 
{ 
    [[ -w "${rvm_archives_path}" ]] || { 
        rvm_error "Archives path '${rvm_archives_path}' not writable, aborting.";
        return 1
    };
    [[ ! -e "${rvm_archives_path}/rvm-installer" ]] || rm -f "${rvm_archives_path}/rvm-installer" || { 
        rvm_error "Previous installer '${rvm_archives_path}/rvm-installer' exists and can not be removed, aborting.";
        return 2
    }
}
__rvm_cli_install_ruby () 
{ 
    ( if [[ -n "$1" ]]; then
        \typeset __rubies __installed __missing __search_list;
        \typeset -a __search;
        __rvm_custom_separated_array __search , "$1";
        __rubies="$1";
        __search_list="";
        __rvm_cli_rubies_select || return $?;
        if __rvm_cli_rubies_not_installed; then
            __rvm_run_wrapper manage install "${__rubies}" || return $?;
        fi;
    else
        rvm_error "Can not use or install 'all' rubies.";
        false;
    fi )
}
__rvm_cli_load_rvmrc () 
{ 
    if (( ${rvm_ignore_rvmrc:=0} == 0 )); then
        [[ -n "${rvm_stored_umask:-}" ]] || export rvm_stored_umask=$(umask);
        rvm_rvmrc_files=("/etc/rvmrc" "$HOME/.rvmrc");
        if [[ -n "${rvm_prefix:-}" ]] && [[ ! "$HOME/.rvmrc" -ef "${rvm_prefix}/.rvmrc" ]]; then
            rvm_rvmrc_files+=("${rvm_prefix}/.rvmrc");
        fi;
        for rvmrc in "${rvm_rvmrc_files[@]}";
        do
            if [[ -f "$rvmrc" ]]; then
                if __rvm_grep '^\s*rvm .*$' "$rvmrc" > /dev/null 2>&1; then
                    printf "%b" "
Error:
        $rvmrc is for rvm settings only.
        rvm CLI may NOT be called from within $rvmrc.
        Skipping the loading of $rvmrc";
                    return 1;
                else
                    source "$rvmrc";
                fi;
            fi;
        done;
        unset rvm_rvmrc_files;
    fi
}
__rvm_cli_posix_check () 
{ 
    if __rvm_has_opt "posix"; then
        echo "RVM can not be run with \`set -o posix\`, please turn it off and try again.";
        return 100;
    fi
}
__rvm_cli_rubies_not_installed () 
{ 
    if (( ${rvm_force_flag:-0} == 0 )) && __installed="$(
      __rvm_list_strings | __rvm_grep -E "${__search_list}"
    )" && [[ -n "${__installed}" ]]; then
        rvm_warn "Already installed ${__installed//|/,}.
To reinstall use:

    rvm reinstall ${__installed//|/,}
";
        return 2;
    fi;
    true
}
__rvm_cli_rubies_select () 
{ 
    \typeset __ruby;
    for __ruby in "${__search[@]}";
    do
        rvm_ruby_string="${__ruby}";
        __rvm_select && if [[ -n "$rvm_ruby_string" ]]; then
            __search_list+="^$rvm_ruby_string\$|";
        else
            rvm_error "Could not detect ruby version/name for installation '${__ruby}', please be more specific.";
            return 1;
        fi;
    done;
    __search_list="${__search_list%|}"
}
__rvm_cli_rvm_get () 
{ 
    case "$1" in 
        [0-9]*.[0-9]*.[0-9]*)
            rvm_warn "
Hi there, it looks like you have requested updating rvm to version $1,
if your intention was ruby installation use instead: rvm install $1
"
        ;;
    esac;
    case "$1" in 
        stable | master | head | branch | latest | latest-* | [0-9]*.[0-9]*.[0-9]*)
            __rvm_cli_get_and_execute_installer "$@" || return $?;
            \typeset -x rvm_hook;
            rvm_hook="after_update";
            source "${rvm_scripts_path:-"$rvm_path/scripts"}/hook";
            rvm_reload_flag=1
        ;;
        *)
            rvm_help get
        ;;
    esac
}
__rvm_cli_rvm_reload () 
{ 
    __rvm_project_rvmrc_lock=0;
    rvm_reload_flag=1;
    source "${rvm_scripts_path:-${rvm_path}/scripts}/rvm"
}
__rvm_cli_version_check () 
{ 
    \typeset disk_version;
    disk_version="$( __rvm_version_installed )";
    if [[ -s "$rvm_path/VERSION" && "${rvm_version:-}" != "${disk_version:-}" && " $* " != *" reload "* ]]; then
        if (( ${rvm_auto_reload_flag:-0} )); then
            __rvm_cli_rvm_reload;
        else
            printf "%b" "
RVM version ${disk_version} is installed yet ${rvm_version} is loaded.
Please do one of the following:
  * 'rvm reload'
  * open a new shell
  * 'echo rvm_auto_reload_flag=1 >> ~/.rvmrc' # for auto reload with msg.
  * 'echo rvm_auto_reload_flag=2 >> ~/.rvmrc' # for silent auto reload.

";
            return 1;
        fi;
    fi
}
__rvm_conditionally_add_bin_path () 
{ 
    [[ ":${PATH}:" == *":${rvm_bin_path}:"* ]] || { 
        if [[ "${rvm_ruby_string:-"system"}" == "system" && -z "$GEM_HOME" ]]; then
            PATH="$PATH:${rvm_bin_path}";
        else
            PATH="${rvm_bin_path}:$PATH";
        fi
    }
}
__rvm_conditionally_do_with_env () 
{ 
    if (( __rvm_env_loaded > 0 )); then
        "$@";
    else
        __rvm_do_with_env "$@";
    fi
}
__rvm_cp () 
{ 
    \cp "$@" || return $?
}
__rvm_curl () 
{ 
    ( \typeset curl_path;
    if [[ "${_system_name} ${_system_version}" == "Solaris 10" ]] && ! __rvm_which curl > /dev/null 2>&1; then
        curl_path=/opt/csw/bin/;
    else
        curl_path="";
    fi;
    __rvm_which ${curl_path}curl > /dev/null 2>&1 || { 
        rvm_error "RVM requires 'curl'. Install 'curl' first and try again.";
        return 200
    };
    \typeset -a __flags;
    __flags=(--fail --location);
    if [[ -n "${rvm_curl_flags[*]}" ]]; then
        __flags+=("${rvm_curl_flags[@]}");
    else
        __flags+=(--max-redirs 10 --max-time 1800);
    fi;
    [[ "$*" == *"--max-time"* ]] || [[ "$*" == *"--connect-timeout"* ]] || [[ "${__flags[*]}" == *"--connect-timeout"* ]] || __flags+=(--connect-timeout 30 --retry-delay 2 --retry 3);
    if [[ -n "${rvm_proxy:-}" ]]; then
        __flags+=(--proxy "${rvm_proxy:-}");
    fi;
    __rvm_curl_output_control;
    unset curl;
    __rvm_debug_command ${curl_path}curl "${__flags[@]}" "$@" || return $? )
}
__rvm_curl_output_control () 
{ 
    if (( ${rvm_quiet_curl_flag:-0} == 1 )); then
        __flags+=("--silent" "--show-error");
    else
        if [[ " $*" == *" -s"* || " $*" == *" --silent"* ]]; then
            [[ " $*" == *" -S"* || " $*" == *" -sS"* || " $*" == *" --show-error"* ]] || { 
                __flags+=("--show-error")
            };
        fi;
    fi
}
__rvm_current_gemset () 
{ 
    \typeset current_gemset;
    current_gemset="${GEM_HOME:-}";
    current_gemset="${current_gemset##*${rvm_gemset_separator:-@}}";
    if [[ "${current_gemset}" == "${GEM_HOME:-}" ]]; then
        echo '';
    else
        echo "${current_gemset}";
    fi
}
__rvm_custom_separated_array () 
{ 
    \typeset IFS;
    IFS=$2;
    if [[ -n "${ZSH_VERSION:-}" ]]; then
        eval "$1+=( \${=3} )";
    else
        eval "$1+=( \$3 )";
    fi
}
__rvm_date () 
{ 
    \date "$@" || return $?
}
__rvm_db () 
{ 
    \typeset value key variable;
    key="${1:-}";
    variable="${2:-}";
    value="";
    if [[ -f "$rvm_user_path/db" ]]; then
        value="$( __rvm_db_ "$rvm_user_path/db"   "$key" )";
    fi;
    if [[ -z "$value" && -f "$rvm_path/config/db" ]]; then
        value="$( __rvm_db_ "$rvm_path/config/db" "$key" )";
    fi;
    [[ -n "$value" ]] || return 1;
    if [[ -n "$variable" ]]; then
        eval "$variable='$value'";
    else
        echo "$value";
    fi;
    true
}
__rvm_db_ () 
{ 
    \typeset __db __key __value;
    __db="$1";
    __key="${2%%\?*}";
    shift 2;
    __value="$*";
    case "${__value}" in 
        unset | delete)
            __rvm_db_remove "${__db}" "${__key}"
        ;;
        "")
            __rvm_db_get "${__db}" "${__key}"
        ;;
        *)
            __rvm_db_add "${__db}" "${__key}" "${__value}"
        ;;
    esac
}
__rvm_db_add () 
{ 
    \typeset __dir="${1%/*}";
    if [[ -f "${1}" ]]; then
        __rvm_db_remove "${1}" "${2}";
    else
        if [[ ! -d "${__dir}" ]]; then
            mkdir -p "${__dir}";
        fi;
    fi;
    printf "%b=%b\n" "$2" "$3" >> "$1"
}
__rvm_db_get () 
{ 
    if [[ -f "$1" ]]; then
        __rvm_sed -n -e "\#^$2=# { s#^$2=##;; p; }" -e '/^$/d' < "$1";
    else
        echo -n "";
    fi
}
__rvm_db_remove () 
{ 
    if [[ -f "$1" ]]; then
        __rvm_sed -e "\#^$2=# d" -e '/^$/d' "$1" > "$1.new";
        \command \mv -f "$1.new" "$1";
    fi
}
__rvm_db_system () 
{ 
    \typeset __key __message;
    for __key in "${_system_name}_${_system_version}_$1" "${_system_name}_$1" "$1";
    do
        if __rvm_db "${__key}_error" __message; then
            rvm_error "${__message}";
        fi;
        if __rvm_db "${__key}_warn" __message; then
            rvm_warn "${__message}";
        fi;
        if __rvm_db "${__key}" "$2"; then
            return 0;
        fi;
    done;
    true
}
__rvm_debug_command () 
{ 
    rvm_debug "Running($#): $*";
    "$@" || return $?
}
__rvm_detect_debian_major_version_from_codename () 
{ 
    case $_system_version in 
        stretch*)
            _system_version="9"
        ;;
        jessie*)
            _system_version="8"
        ;;
        wheezy*)
            _system_version="7"
        ;;
        squeeze*)
            _system_version="6"
        ;;
        lenny*)
            _system_version="5"
        ;;
        etch*)
            _system_version="4"
        ;;
        sarge*)
            _system_version="3"
        ;;
        woody*)
            _system_version="3"
        ;;
        potato*)
            _system_version="2"
        ;;
        slink*)
            _system_version="2"
        ;;
        hamm*)
            _system_version="2"
        ;;
    esac
}
__rvm_detect_system () 
{ 
    unset _system_type _system_name _system_version _system_arch;
    export _system_type _system_name _system_version _system_arch;
    _system_info="$(command uname -a)";
    _system_type="unknown";
    _system_name="unknown";
    _system_name_lowercase="unknown";
    _system_version="unknown";
    _system_arch="$(command uname -m)";
    case "$(command uname)" in 
        Linux | GNU*)
            _system_type="Linux";
            if [[ -f /etc/lsb-release ]] && __rvm_detect_system_from_lsb_release; then
                :;
            else
                if [[ -f /etc/os-release ]] && __rvm_detect_system_from_os_release; then
                    :;
                else
                    if [[ -f /etc/altlinux-release ]]; then
                        _system_name="Arch";
                        _system_version="libc-$(ldd --version  | \command \awk 'NR==1 {print $NF}' | \command \awk -F. '{print $1"."$2}' | head -n 1)";
                    else
                        if [[ -f /etc/SuSE-release ]]; then
                            _system_name="SuSE";
                            _system_version="$( \command \awk -F'=' '{gsub(/ /,"")} $1~/VERSION/ {version=$2} $1~/PATCHLEVEL/ {patch=$2} END {print version"."patch}' < /etc/SuSE-release )";
                        else
                            if [[ -f /etc/devuan_version ]]; then
                                _system_name="Devuan";
                                _system_version="$(\command \cat /etc/devuan_version | \command \awk -F. '{print $1}' | head -n 1)";
                                _system_arch="$( dpkg --print-architecture )";
                            else
                                if [[ -f /etc/system-release ]] && GREP_OPTIONS="" \command \grep "Amazon Linux AMI" /etc/system-release > /dev/null; then
                                    _system_name="Amazon";
                                    _system_version="$(GREP_OPTIONS="" \command \grep -Eo '[0-9\.]+' /etc/system-release | \command \awk -F. '{print $1"."$2}' | head -n 1)";
                                else
                                    if [[ -f /etc/sabayon-release ]]; then
                                        _system_name="Sabayon";
                                        _system_version="$(\command \cat /etc/sabayon-release | \command \awk 'NR==1 {print $NF}' | \command \awk -F. '{print $1"."$2}' | head -n 1)";
                                    else
                                        if [[ -f /etc/gentoo-release ]]; then
                                            _system_name="Gentoo";
                                            _system_version="base-$(\command \cat /etc/gentoo-release | \command \awk 'NR==1 {print $NF}' | \command \awk -F. '{print $1"."$2}' | head -n 1)";
                                        else
                                            if [[ -f /etc/arch-release ]]; then
                                                _system_name="Arch";
                                                _system_version="libc-$(ldd --version  | \command \awk 'NR==1 {print $NF}' | \command \awk -F. '{print $1"."$2}' | head -n 1)";
                                            else
                                                if [[ -f /etc/fedora-release ]]; then
                                                    _system_name="Fedora";
                                                    _system_version="$(GREP_OPTIONS="" \command \grep -Eo '[0-9]+' /etc/fedora-release | head -n 1)";
                                                else
                                                    if [[ -f /etc/oracle-release ]]; then
                                                        _system_name="Oracle";
                                                        _system_version="$(GREP_OPTIONS="" \command \grep -Eo '[0-9\.]+' /etc/oracle-release  | \command \awk -F. '{print $1}' | head -n 1)";
                                                    else
                                                        if [[ -f /etc/redhat-release ]]; then
                                                            _system_name="$( GREP_OPTIONS="" \command \grep -Eo 'CentOS|PCLinuxOS|ClearOS|Mageia|Scientific|ROSA Desktop|OpenMandriva' /etc/redhat-release 2>/dev/null | \command \head -n 1 | \command \sed "s/ //" )";
                                                            _system_name="${_system_name:-CentOS}";
                                                            _system_version="$(GREP_OPTIONS="" \command \grep -Eo '[0-9\.]+' /etc/redhat-release  | \command \awk -F. 'NR==1{print $1}' | head -n 1)";
                                                            _system_arch="$( uname -m )";
                                                        else
                                                            if [[ -f /etc/centos-release ]]; then
                                                                _system_name="CentOS";
                                                                _system_version="$(GREP_OPTIONS="" \command \grep -Eo '[0-9\.]+' /etc/centos-release  | \command \awk -F. '{print $1}' | head -n 1)";
                                                            else
                                                                if [[ -f /etc/debian_version ]]; then
                                                                    _system_name="Debian";
                                                                    _system_version="$(\command \cat /etc/debian_version | \command \awk -F. '{print $1}' | head -n 1)";
                                                                    _system_arch="$( dpkg --print-architecture )";
                                                                    __rvm_detect_debian_major_version_from_codename;
                                                                else
                                                                    if [[ -f /proc/devices ]] && GREP_OPTIONS="" \command \grep -Eo "synobios" /proc/devices > /dev/null; then
                                                                        _system_type="BSD";
                                                                        _system_name="Synology";
                                                                        _system_version="libc-$(ldd --version  | \command \awk 'NR==1 {print $NF}' | \command \awk -F. '{print $1"."$2}' | head -n 1)";
                                                                    else
                                                                        _system_version="libc-$(ldd --version  | \command \awk 'NR==1 {print $NF}' | \command \awk -F. '{print $1"."$2}' | head -n 1)";
                                                                    fi;
                                                                fi;
                                                            fi;
                                                        fi;
                                                    fi;
                                                fi;
                                            fi;
                                        fi;
                                    fi;
                                fi;
                            fi;
                        fi;
                    fi;
                fi;
            fi
        ;;
        SunOS)
            _system_type="SunOS";
            _system_name="Solaris";
            _system_version="$(command uname -v)";
            _system_arch="$(command isainfo -k)";
            if [[ "${_system_version}" == joyent* ]]; then
                _system_name="SmartOS";
                _system_version="${_system_version#* }";
            else
                if [[ "${_system_version}" == omnios* ]]; then
                    _system_name="OmniOS";
                    _system_version="${_system_version#* }";
                else
                    if [[ "${_system_version}" == oi* || "${_system_version}" == illumos* ]]; then
                        _system_name="OpenIndiana";
                        _system_version="${_system_version#* }";
                    else
                        if [[ "${_system_version}" == Generic* ]]; then
                            _system_version="10";
                        else
                            if [[ "${_system_version}" == *11* ]]; then
                                _system_version="11";
                            fi;
                        fi;
                    fi;
                fi;
            fi
        ;;
        FreeBSD)
            _system_type="BSD";
            _system_name="FreeBSD";
            _system_version="$(command uname -r)";
            _system_version="${_system_version%%-*}"
        ;;
        OpenBSD)
            _system_type="BSD";
            _system_name="OpenBSD";
            _system_version="$(command uname -r)"
        ;;
        DragonFly)
            _system_type="BSD";
            _system_name="DragonFly";
            _system_version="$(command uname -r)";
            _system_version="${_system_version%%-*}"
        ;;
        NetBSD)
            _system_type="BSD";
            _system_name="NetBSD";
            _system_version_full="$(command uname -r)";
            _system_version="$(echo ${_system_version_full} | \command \awk -F. '{print $1"."$2}')"
        ;;
        Darwin)
            _system_type="Darwin";
            _system_name="OSX";
            _system_version="$(sw_vers -productVersion | \command \awk -F. '{print $1"."$2}')"
        ;;
        CYGWIN*)
            _system_type="Windows";
            _system_name="Cygwin"
        ;;
        MINGW*)
            _system_type="Windows";
            _system_name="Mingw"
        ;;
        *)
            return 1
        ;;
    esac;
    _system_type="${_system_type//[ \/]/_}";
    _system_name="${_system_name//[ \/]/_}";
    _system_name_lowercase="$(echo ${_system_name} | \command \tr '[A-Z]' '[a-z]')";
    _system_version="${_system_version//[ \/]/_}";
    _system_arch="${_system_arch//[ \/]/_}";
    _system_arch="${_system_arch/amd64/x86_64}";
    _system_arch="${_system_arch/i[123456789]86/i386}"
}
__rvm_detect_system_from_lsb_release () 
{ 
    local __system_name="$( awk -F'=' '$1=="DISTRIB_ID"{print $2}' /etc/lsb-release | head -n 1 | tr '[A-Z]' '[a-z]' | tr -d \" )";
    case $__system_name in 
        deepin*)
            _system_name="Deepin"
        ;;
        elementary*)
            _system_name="Elementary"
        ;;
        kali*)
            _system_name="Kali"
        ;;
        linuxmint*)
            _system_name="Mint"
        ;;
        manjarolinux*)
            _system_name="Manjaro"
        ;;
        solus*)
            _system_name="Solus"
        ;;
        neon*)
            _system_name="Ubuntu"
        ;;
        ubuntu*)
            _system_name="Ubuntu"
        ;;
        zorin*)
            _system_name="Ubuntu"
        ;;
        *)
            return 1
        ;;
    esac;
    _system_version="$( awk -F'=' '$1=="DISTRIB_RELEASE"{print $2}' /etc/lsb-release | head -n 1 )";
    _system_arch="$( uname -m )";
    return 0
}
__rvm_detect_system_from_os_release () 
{ 
    local __system_name="$( awk -F'=' '$1=="ID"{print $2}' /etc/os-release | head -n 1 | tr '[A-Z]' '[a-z]' | tr -d \" )";
    case $__system_name in 
        opensuse*)
            _system_name="OpenSuSE";
            _system_version="$( awk -F'=' '$1=="VERSION_ID"{gsub(/"/,"");print $2}' /etc/os-release | head -n 1 )";
            _system_arch="$( uname -m )"
        ;;
        pclinuxos*)
            _system_name="PCLinuxOS";
            _system_version="$(GREP_OPTIONS="" \command \grep -Eo '[0-9\.]+' /etc/redhat-release  | \command \awk -F. '{print $1}' | head -n 1)";
            _system_arch="$( uname -m )"
        ;;
        debian*)
            _system_name="Debian";
            _system_version="$(awk -F'=' '$1=="VERSION_ID"{gsub(/"/,"");print $2}' /etc/os-release | \command \awk -F. '{print $1}' | head -n 1)";
            _system_arch="$( dpkg --print-architecture )";
            __rvm_detect_debian_major_version_from_codename
        ;;
        *)
            return 1
        ;;
    esac;
    return 0
}
__rvm_detect_system_override () 
{ 
    \typeset _var;
    for _var in system_type system_name system_name_lowercase system_version system_arch;
    do
        __rvm_db ${_var} _${_var};
    done
}
__rvm_detect_xcode_version () 
{ 
    \typeset version_file;
    for version_file in /Applications/Xcode.app/Contents/version.plist /Developer/Applications/Xcode.app/Contents/version.plist;
    do
        if [[ -f $version_file ]]; then
            if [[ -x /usr/libexec/PlistBuddy ]]; then
                /usr/libexec/PlistBuddy -c "Print CFBundleShortVersionString" $version_file;
            else
                __rvm_sed -n '/<key>CFBundleShortVersionString<\/key>/{n; s/^.*>\(.*\)<.*$/\1/; p;}' < $version_file;
            fi;
            return 0;
        fi;
    done;
    if builtin command -v xcodebuild > /dev/null; then
        xcodebuild -version | __rvm_sed -n '/Xcode/ {s/Xcode //; p;}';
        return 0;
    fi;
    return 1
}
__rvm_detect_xcode_version_at_least () 
{ 
    \typeset __xcode_version="$(__rvm_detect_xcode_version)";
    [[ -n "$__xcode_version" ]] || return 0;
    __rvm_version_compare "$__xcode_version" -ge "$1" || return $?;
    true
}
__rvm_display_rvmrc () 
{ 
    __rvm_file_notice_display_pre;
    __rvm_wait_anykey "(( press a key to review the ${_rvmrc_base} file ))";
    printf "%b" "${rvm_warn_clr}";
    command cat -v "${_rvmrc}";
    printf "%b" "${rvm_reset_clr}";
    __rvm_file_notice_display_post
}
__rvm_do_with_env () 
{ 
    \typeset result;
    __rvm_do_with_env_before;
    "$@";
    result=$?;
    __rvm_do_with_env_after;
    return ${result:-0}
}
__rvm_do_with_env_after () 
{ 
    __rvm_teardown
}
__rvm_do_with_env_before () 
{ 
    if [[ -n "${rvm_scripts_path:-}" || -n "${rvm_path:-}" ]]; then
        source "${rvm_scripts_path:-"$rvm_path/scripts"}/initialize";
        __rvm_setup;
    fi
}
__rvm_dotted () 
{ 
    set +x;
    \typeset flush;
    if (( $# )); then
        printf "%b" "${rvm_notify_clr:-}$*${rvm_reset_clr:-}";
    fi;
    if __rvm_awk '{fflush;}' <<< EO 2> /dev/null; then
        flush=fflush;
    else
        flush=flush;
    fi;
    awk -v go_back="$( tput cub1 2>/dev/null || true)" '
  BEGIN{
    spin[0]="|"go_back;
    spin[1]="/"go_back;
    spin[2]="-"go_back;
    spin[3]="\\"go_back }
  {
    if ((NR-1)%(10)==9)
      printf ".";
    else
      if (go_back!="") printf spin[(NR-1)%4];
    '${flush}' }
  END{
    print "." }
  '
}
__rvm_ensure_has_environment_files () 
{ 
    \typeset file_name variable value environment_id __path __gem_home;
    __gem_home="${rvm_ruby_gem_home}";
    file_name="${__gem_home}/environment";
    __path="";
    if [[ "${__gem_home##*@}" != "global" ]]; then
        __path+="${__gem_home}/bin:";
    fi;
    __path+="${rvm_ruby_global_gems_path}/bin:${rvm_ruby_home}/bin";
    \command \rm -f "$file_name";
    \command \mkdir -p "${__gem_home}/wrappers" "${rvm_environments_path}" "${rvm_wrappers_path}";
    printf "%b" "export PATH=\"${__path}:\$PATH\"\n" > "$file_name";
    for variable in GEM_HOME GEM_PATH MY_RUBY_HOME IRBRC MAGLEV_HOME RBXOPT RUBY_VERSION;
    do
        eval "value=\${${variable}:-""}";
        if [[ -n "$value" ]]; then
            printf "export %b='%b'\n" "${variable}" "${value}" >> "$file_name";
        else
            printf "unset %b\n" "${variable}" >> "$file_name";
        fi;
    done;
    environment_id="${__gem_home##*/}";
    [[ -L "${rvm_environments_path}/${environment_id}" ]] || { 
        if [[ -f "${rvm_environments_path}/${environment_id}" ]]; then
            rm -rf "${rvm_environments_path}/${environment_id}";
        fi;
        ln -nfs "${__gem_home}/environment" "${rvm_environments_path}/${environment_id}"
    };
    ln -nfs "${__gem_home}/wrappers" "$rvm_wrappers_path/${environment_id}";
    return 0
}
__rvm_ensure_is_a_function () 
{ 
    if [[ ${rvm_reload_flag:=0} == 1 ]] || ! is_a_function rvm; then
        for script in functions/version functions/selector cd functions/cli cli override_gem;
        do
            if [[ -f "$rvm_scripts_path/$script" ]]; then
                source "$rvm_scripts_path/$script";
            else
                printf "%b" "WARNING:
        Could not source '$rvm_scripts_path/$script' as file does not exist.
        RVM will likely not work as expected.\n";
            fi;
        done;
    fi
}
__rvm_env_file_notice_display_post () 
{ 
    __rvm_table "Viewing of ${_rvmrc} complete."  <<-TEXT
Trusting an ${_rvmrc_base} file means that whenever you cd into this directory, RVM will export environment variables from ${_rvmrc_base}.
Note that if the contents of the file change, you will be re-prompted to review the file and adjust its trust settings. You may also change the trust settings manually at any time with the 'rvm rvmrc' command.
TEXT

}
__rvm_env_file_notice_initial () 
{ 
    __rvm_table "NOTICE"  <<-TEXT
RVM has encountered a new or modified ${_rvmrc_base} file in the current directory, environment variables from this file will be exported and therefore may influence your shell.

Examine the contents of this file carefully to be sure the contents are safe before trusting it!
Do you wish to trust '${_rvmrc}'?
Choose v[iew] below to view the contents
TEXT

}
__rvm_env_print () 
{ 
    environment_file_path="$rvm_environments_path/$(__rvm_env_string)";
    if [[ "$rvm_path_flag" == "1" || "$*" == *"--path"* ]]; then
        echo "$environment_file_path";
    else
        if [[ "$rvm_cron_flag" == "1" || "$*" == *"--cron"* ]]; then
            \command \cat "$environment_file_path" | __rvm_grep -Eo "[^ ]+=[^;]+" | __rvm_sed -e 's/\$PATH/'"${PATH//\//\\/}"'/' -e 's/\${PATH}/'"${PATH//\//\\/}"'/';
        else
            \command \cat "$environment_file_path";
        fi;
    fi
}
__rvm_env_string () 
{ 
    \typeset _string;
    _string="${GEM_HOME:-}";
    _string="${_string##*/}";
    printf "%b" "${_string:-system}\n"
}
__rvm_expand_ruby_string () 
{ 
    \typeset string current_ruby;
    string="$1";
    case "${string:-all}" in 
        all)
            __rvm_list_strings | \command \tr ' ' "\n"
        ;;
        all-gemsets)
            __rvm_list_gemset_strings
        ;;
        default-with-rvmrc | rvmrc)
            "$rvm_scripts_path/tools" path-identifier "$PWD"
        ;;
        all-rubies | rubies)
            __rvm_list_strings
        ;;
        current-ruby | gemsets)
            current_ruby="$(__rvm_env_string)";
            current_ruby="${current_ruby%@*}";
            rvm_silence_logging=1 "$rvm_scripts_path/gemsets" list strings | __rvm_sed "s/ (default)//; s/^/$current_ruby${rvm_gemset_separator:-@}/ ; s/@default// ;"
        ;;
        current)
            __rvm_env_string
        ;;
        aliases)
            __rvm_awk -F= '{print $string}' < "$rvm_path/config/alias"
        ;;
        *)
            __rvm_ruby_strings_exist $( echo "$string" | \command \tr "," "\n" | __rvm_strip )
        ;;
    esac
}
__rvm_export () 
{ 
    \typeset name;
    name=${1%%\=*};
    builtin export rvm_old_$name=${!name};
    export "$@";
    return $?
}
__rvm_file_env_check_unload () 
{ 
    if (( ${#rvm_saved_env[@]} > 0 )); then
        __rvm_set_env "" "${rvm_saved_env[@]}";
    fi;
    rvm_saved_env=()
}
__rvm_file_load_env () 
{ 
    \typeset -a __sed_commands;
    __sed_commands=();
    if [[ -n "${2:-}" ]]; then
        __sed_commands+=(-e "/^$2/ !d" -e "s/^$2//");
    else
        __sed_commands+=(-e "/^#/ d" -e "/^$/ d");
    fi;
    __rvm_read_lines __file_env_variables <( { cat "$1"; echo ""; } | __rvm_sed "${__sed_commands[@]}" )
}
__rvm_file_load_env_and_trust () 
{ 
    [[ -f "$1" ]] || return 0;
    __rvm_file_load_env "$1" "${2:-}";
    if (( ${#__file_env_variables[@]} == 0 )) || __rvm_check_rvmrc_trustworthiness "$1"; then
        true;
    else
        rvm_debug "Envirionment variables variables from '$1' wont be loaded because of lack of trust (status=$?).";
        __file_env_variables=();
    fi
}
__rvm_file_notice_display_post () 
{ 
    case "${_rvmrc}" in 
        */.rvmrc)
            __rvm_rvmrc_notice_display_post
        ;;
        *)
            __rvm_env_file_notice_display_post
        ;;
    esac
}
__rvm_file_notice_display_pre () 
{ 
    __rvm_table  <<-TEXT
The contents of the ${_rvmrc_base} file will now be displayed.
After reading the file, you will be prompted again for 'yes or no' to set the trust level for this particular version of the file.

Note: You will be re-prompted each time the ${_rvmrc_base} file's contents change
changes, and may change the trust setting manually at any time.
TEXT

}
__rvm_file_notice_initial () 
{ 
    case "${_rvmrc}" in 
        */.rvmrc)
            __rvm_rvmrc_notice_initial
        ;;
        *)
            __rvm_env_file_notice_initial
        ;;
    esac
}
__rvm_file_set_env () 
{ 
    __rvm_file_env_check_unload;
    __rvm_set_env "rvm_saved_env" "${__file_env_variables[@]}"
}
__rvm_find () 
{ 
    \find "$@" || return $?
}
__rvm_find_first_file () 
{ 
    \typeset _first_file _variable_first_file __file_enum;
    _first_file="";
    _variable_first_file="$1";
    shift;
    for __file_enum in "$@";
    do
        if [[ -f "$__file_enum" ]]; then
            eval "$_variable_first_file=\"\$__file_enum\"";
            return 0;
        fi;
    done;
    eval "$_variable_first_file=\"\"";
    return 1
}
__rvm_fix_group_permissions () 
{ 
    if \umask -S | __rvm_grep 'g=rw' > /dev/null; then
        chmod -R g+rwX "$@";
    fi
}
__rvm_fix_path_from_gem_path () 
{ 
    [[ -n "${GEM_PATH:-}" ]] || return 0;
    export PATH;
    \typeset IFS _iterator_path;
    \typeset -a _gem_path _new_path;
    IFS=:;
    _gem_path=();
    _new_path=();
    __rvm_custom_separated_array _gem_path : "${GEM_PATH}";
    for _iterator_path in "${_gem_path[@]}";
    do
        _new_path+=("${_iterator_path}/bin");
    done;
    _new_path+=("${MY_RUBY_HOME:-${GEM_HOME/gems/rubies}}/bin");
    _new_path+=("${rvm_bin_path}");
    PATH="${_new_path[*]}:$PATH";
    builtin hash -r
}
__rvm_fix_selected_ruby () 
{ 
    \typeset __ret=0;
    if (( $# )); then
        "$@" || __ret=$?;
    fi;
    [[ -d "$GEM_HOME" && -d "$MY_RUBY_HOME" ]] || { 
        if [[ -d ${MY_RUBY_HOME%/*}/defaul ]]; then
            __rvm_use default;
        else
            __rvm_use system;
        fi
    }
}
__rvm_fold () 
{ 
    if fold -s -w 10 <<< bla > /dev/null; then
        fold -s -w $1;
    else
        fold -w $1;
    fi
}
__rvm_gemset_handle_default () 
{ 
    rvm_gemset_name="${rvm_gemset_separator:-@}${rvm_gemset_name:-}${rvm_gemset_separator:-@}";
    rvm_gemset_name="${rvm_gemset_name/${rvm_gemset_separator:-@}default${rvm_gemset_separator:-@}/}";
    rvm_gemset_name="${rvm_gemset_name//${rvm_gemset_separator:-@}/}"
}
__rvm_gemset_pristine () 
{ 
    __rvm_log_command "gemset.pristine-$1" "Making gemset $1 pristine" __rvm_with "$1" gemset_pristine
}
__rvm_gemset_select () 
{ 
    __rvm_gemset_select_only && __rvm_gemset_select_validation || return $?
}
__rvm_gemset_select_cli () 
{ 
    __rvm_gemset_select_cli_validation && __rvm_gemset_select || return $?
}
__rvm_gemset_select_cli_validation () 
{ 
    \typeset orig_gemset;
    if ! builtin command -v gem > /dev/null; then
        rvm_log "'gem' command not found, cannot select a gemset.";
        return 0;
    fi;
    orig_gemset="${rvm_gemset_name:-}";
    __rvm_gemset_handle_default;
    if [[ -z "${rvm_gemset_name:-}" && "$orig_gemset" != "default" && ${rvm_sticky_flag:-0} -eq 1 ]]; then
        if [[ -n "${rvm_ruby_gem_home:-}" ]]; then
            rvm_gemset_name="$rvm_ruby_gem_home";
        else
            if [[ -n "${GEM_HOME:-}" ]]; then
                rvm_gemset_name="$GEM_HOME";
            fi;
        fi;
        rvm_gemset_name="${rvm_gemset_name##*/}";
        rvm_gemset_name="${rvm_gemset_name#*${rvm_gemset_separator:-"@"}}";
    fi;
    if [[ -z "${rvm_ruby_string:-}" && -n "${GEM_HOME:-}" && -n "${GEM_HOME%@*}" ]]; then
        rvm_ruby_string="${GEM_HOME%@*}";
        rvm_ruby_string="${rvm_ruby_string##*/}";
    fi;
    if [[ -z "${rvm_ruby_string:-}" ]]; then
        rvm_error "Gemsets can not be used with non rvm controlled rubies (currently).";
        return 3;
    fi
}
__rvm_gemset_select_only () 
{ 
    rvm_ruby_gem_home="${rvm_gems_path:-"$rvm_path/gems"}/$rvm_ruby_string";
    : rvm_ignore_gemsets_flag:${rvm_ignore_gemsets_flag:=0}:;
    if (( rvm_ignore_gemsets_flag )); then
        rvm_ruby_global_gems_path="${rvm_ruby_gem_home}";
        rvm_ruby_gem_path="${rvm_ruby_gem_home}";
        rvm_gemset_name="";
    else
        rvm_ruby_global_gems_path="${rvm_ruby_gem_home}${rvm_gemset_separator:-"@"}global";
        __rvm_gemset_handle_default;
        [[ -z "$rvm_gemset_name" ]] || rvm_ruby_gem_home="${rvm_ruby_gem_home}${rvm_gemset_separator:-"@"}${rvm_gemset_name}";
        if [[ "$rvm_gemset_name" == "global" ]]; then
            rvm_ruby_gem_path="${rvm_ruby_gem_home}";
        else
            rvm_ruby_gem_path="${rvm_ruby_gem_home}:${rvm_ruby_global_gems_path}";
        fi;
    fi;
    if [[ -n "${rvm_gemset_name}" ]]; then
        rvm_env_string="${rvm_ruby_string}@${rvm_gemset_name}";
    else
        rvm_env_string=${rvm_ruby_string};
    fi;
    true
}
__rvm_gemset_select_validation () 
{ 
    if [[ ! -d "${rvm_ruby_gem_home}" ]]; then
        if (( ${rvm_gemset_create_on_use_flag:=0} == 0 && ${rvm_create_flag:=0} == 0 && ${rvm_delete_flag:=0} == 0 )); then
            rvm_expected_gemset_name="${rvm_gemset_name}";
            rvm_gemset_name="";
            __rvm_gemset_select_only;
            return 2;
        fi;
    else
        if (( ${rvm_delete_flag:=0} == 1 )); then
            return 4;
        fi;
    fi;
    case "${rvm_gemset_name}" in 
        */*)
            rvm_error "Gemsets can not contain path separator '/'.";
            return 5
        ;;
        *:*)
            rvm_error "Gemsets can not contain PATH separator ':'.";
            return 5
        ;;
    esac;
    \typeset rvm_ruby_gem_home_254;
    if [[ -n "${ZSH_VERSION:-}" ]]; then
        rvm_ruby_gem_home_254="${rvm_ruby_gem_home[0,254]}";
    else
        rvm_ruby_gem_home_254="${rvm_ruby_gem_home:0:254}";
    fi;
    if [[ "${rvm_ruby_gem_home}" != "${rvm_ruby_gem_home_254}" ]]; then
        rvm_error "Gemset gem home to long ${#rvm_ruby_gem_home}.";
        return 6;
    fi
}
__rvm_gemset_use () 
{ 
    if [[ "$(__rvm_env_string)" == "system" ]]; then
        rvm_error "System ruby is not controlled by RVM, but you can use it with 'rvm automount', read more: 'rvm help mount'.";
        return 2;
    else
        if __rvm_gemset_select_cli; then
            rvm_log "Using $rvm_ruby_string with gemset ${rvm_gemset_name:-default}";
            __rvm_use;
        else
            if [[ -n "${rvm_expected_gemset_name}" ]]; then
                __rvm_gemset_use_ensure;
            else
                rvm_error "Gemset was not given.\n  Usage:\n    rvm gemset use <gemsetname>\n";
                return 1;
            fi;
        fi;
    fi
}
__rvm_gemset_use_ensure () 
{ 
    if [[ ! -d "$rvm_ruby_gem_home" ]] || [[ -n "${rvm_expected_gemset_name}" && ! -d "${rvm_ruby_gem_home%@*}@${rvm_expected_gemset_name}" ]]; then
        if (( ${rvm_gemset_create_on_use_flag:=0} == 1 || ${rvm_create_flag:=0} == 1 )); then
            gemset_create "${rvm_expected_gemset_name:-${rvm_gemset_name:-}}";
        else
            rvm_error "Gemset '${rvm_expected_gemset_name:-${rvm_gemset_name:-}}' does not exist, 'rvm $rvm_ruby_string do rvm gemset create ${rvm_expected_gemset_name:-${rvm_gemset_name:-}}' first, or append '--create'.";
            return 2;
        fi;
    fi
}
__rvm_get_user_shell () 
{ 
    case "${_system_type}:${_system_name}" in 
        Linux:* | SunOS:* | BSD:* | *:Cygwin)
            __shell="$( getent passwd $USER )" || { 
                rvm_error "Error checking user shell via getent ... something went wrong, report a bug.";
                return 2
            };
            echo "${__shell##*:}"
        ;;
        Darwin:*)
            \typeset __version;
            __version="$(dscl localhost -read "/Search/Users/$USER" UserShell)" || { 
                rvm_error "Error checking user shell via dscl ... something went wrong, report a bug.";
                return 3
            };
            echo ${__version#*: }
        ;;
        *)
            rvm_error "Do not know how to check user shell on '$(command uname)'.";
            return 1
        ;;
    esac
}
__rvm_grep () 
{ 
    GREP_OPTIONS="" \command \grep "$@" || return $?
}
__rvm_has_opt () 
{ 
    if [[ -n "${ZSH_VERSION:-}" ]]; then
        setopt | GREP_OPTIONS="" \command \grep "^${1:-}$" > /dev/null 2>&1 || return $?;
    else
        if [[ -n "${KSH_VERSION:-}" ]]; then
            set +o | GREP_OPTIONS="" \command \grep "-o ${1:-}$" > /dev/null 2>&1 || return $?;
        else
            if [[ -n "${BASH_VERSION:-}" ]]; then
                [[ ":${SHELLOPTS:-}:" == *":${1:-}:"* ]] || return $?;
            else
                return 1;
            fi;
        fi;
    fi
}
__rvm_include_travis_binaries () 
{ 
    if [[ $rvm_remote_server_url == *"travis"* && $TRAVIS != true && $_system_name_lowercase == "osx" ]]; then
        rvm_debug "Travis binaries for OSX are not movable and can't be used outside of Travis environment. Skip that source.";
        return 1;
    fi;
    return 0
}
__rvm_initial_gemsets_create () 
{ 
    __rvm_log_command "chmod.bin" "$rvm_ruby_string - #making binaries executable" __rvm_set_executable "$rvm_ruby_home/bin"/* && ( rvm_ruby_binary="${1:-$rvm_ruby_home/bin/ruby}" rubygems_setup ${rvm_rubygems_version:-latest} ) && __rvm_initial_gemsets_create_without_rubygems "$1"
}
__rvm_initial_gemsets_create_without_rubygems () 
{ 
    __rvm_rubygems_create_link "$1" && gemset_create "global" && __rvm_with "${rvm_ruby_string}@global" __rvm_remove_without_gems && gemset_create ""
}
__rvm_initialize () 
{ 
    true ${rvm_scripts_path:="$rvm_path/scripts"};
    export rvm_scripts_path;
    source "$rvm_scripts_path/base";
    __rvm_conditionally_add_bin_path;
    export PATH;
    [[ -d "${rvm_tmp_path:-/tmp}" ]] || command mkdir -p "${rvm_tmp_path}";
    return 0
}
__rvm_join_array () 
{ 
    \typeset IFS;
    IFS="$2";
    eval "$1=\"\${$3[*]}\""
}
__rvm_libtoolize () 
{ 
    \libtoolize "$@" || return $?
}
__rvm_lines_with_gems () 
{ 
    \typeset -a __gems_to_add;
    __gems_to_add=();
    case "${1}" in 
        global)
            __rvm_custom_separated_array __gems_to_add " " "${rvm_with_gems:-}"
        ;;
        default)
            __rvm_custom_separated_array __gems_to_add " " "${rvm_with_default_gems:-}"
        ;;
        *)
            return 0
        ;;
    esac;
    (( ${#__gems_to_add[@]} )) || return 0;
    \typeset __gem __version;
    for __gem in "${__gems_to_add[@]}";
    do
        __version="${__gem#*=}";
        __gem="${__gem%%=*}";
        if [[ "${__gem}" == "${__version}" ]]; then
            lines+=("${__gem}");
        else
            lines+=("${__gem} -v ${__version}");
        fi;
    done
}
__rvm_lines_without_comments () 
{ 
    __rvm_remove_from_array lines "#*|+( )" "${lines[@]}"
}
__rvm_lines_without_gems () 
{ 
    [[ -n "${rvm_without_gems}" ]] || return 0;
    \typeset -a __gems_to_remove;
    __gems_to_remove=();
    __rvm_custom_separated_array __gems_to_remove " " "${rvm_without_gems}";
    (( ${#__gems_to_remove[@]} )) || return 0;
    \typeset __gem;
    for __gem in "${__gems_to_remove[@]}";
    do
        __rvm_remove_from_array lines "${__gem}|${__gem% *} *" "${lines[@]}";
    done
}
__rvm_list_gems () 
{ 
    \typeset __checks __names;
    __checks="${1:-}";
    shift || true;
    __names="$*";
    if [[ -n "${__names}" ]]; then
        __checks="%w{${__names}}.include?(gem.name)${__checks:+" && ( ${__checks} )"}";
    fi;
    if [[ -n "${__checks}" ]]; then
        __checks="if ${__checks}";
    fi;
    rvm_debug "gem list check: ${__checks}";
    ruby -rrubygems -e "
    Gem::Specification.each{|gem|
      puts \"#{gem.name} #{gem.version}\" ${__checks}
    }
  " 2> /dev/null || gem list $@ | __rvm_sed '/\*\*\*/ d ; /^$/ d; s/ (/,/; s/, /,/g; s/)//;' | __rvm_awk -F ',' '{for(i=2;i<=NF;i++) print $1" "$i }'
}
__rvm_list_gemset_strings () 
{ 
    \typeset all_rubies ruby_name gemset;
    all_rubies="$(__rvm_list_strings | tr "\n" ":")";
    for gemset in "${rvm_gems_path:-"$rvm_path/gems"}"/*;
    do
        case "$gemset" in 
            */\* | @* | doc | cache | system)
                continue
            ;;
        esac;
        ruby_name="${gemset%%@*}";
        ruby_name="${ruby_name##*/}";
        case ":$all_rubies" in 
            *:${ruby_name}:*)
                true
            ;;
            *)
                continue
            ;;
        esac;
        echo "${gemset##*/}";
    done | sort;
    return 0
}
__rvm_list_known_strings () 
{ 
    __rvm_sed -e 's/#.*$//g' -e 's#\[##g' -e 's#\]##g' < "$rvm_path/config/known" | sort -r | uniq;
    return $?
}
__rvm_list_strings () 
{ 
    __rvm_find "$rvm_rubies_path" -mindepth 1 -maxdepth 1 -type d | __rvm_awk -F'/' '{print $NF}'
}
__rvm_load_environment () 
{ 
    \typeset __hook;
    if [[ -f "$rvm_environments_path/$1" ]]; then
        unset GEM_HOME GEM_PATH;
        __rvm_remove_rvm_from_path;
        __rvm_conditionally_add_bin_path;
        \. "$rvm_environments_path/$1";
        rvm_hook="after_use";
        if [[ -n "${rvm_scripts_path:-}" || -n "${rvm_path:-}" ]]; then
            source "${rvm_scripts_path:-$rvm_path/scripts}/hook";
        fi;
        builtin hash -r;
    else
        __rvm_use "$1";
    fi
}
__rvm_load_project_config () 
{ 
    rvm_debug "__rvm_load_project_config $1";
    \typeset __gemfile _bundle_install;
    \typeset -a __file_env_variables;
    __file_env_variables=();
    __gemfile="";
    rvm_previous_environment="$(__rvm_env_string)";
    : rvm_autoinstall_bundler_flag:${rvm_autoinstall_bundler_flag:=0};
    case "$1" in 
        */.rvmrc)
            __rvmrc_warning_display_for_rvmrc "$1";
            if __rvm_check_rvmrc_trustworthiness "$1"; then
                __rvm_remove_rvm_from_path;
                __rvm_conditionally_add_bin_path;
                rvm_current_rvmrc="$1";
                __rvm_ensure_is_a_function;
                unset GEM_HOME GEM_PATH;
                rvm_ruby_string="${rvm_previous_environment/system/default}" rvm_action=use source "$1" || return $?;
            else
                return $?;
            fi
        ;;
        */.versions.conf)
            __rvm_ensure_is_a_function;
            rvm_current_rvmrc="$1";
            rvm_ruby_string="$( \command \tr -d '\r' <"$1" | __rvm_sed -n '/^ruby=/ {s/ruby=//;p;}' | tail -n 1 )";
            [[ -n "${rvm_ruby_string}" ]] || return 2;
            rvm_gemset_name="$( \command \tr -d '\r' <"$1" | __rvm_sed -n '/^ruby-gemset=/ {s/ruby-gemset=//;p;}' | tail -n 1 )";
            rvm_create_flag=1 __rvm_use || return 3;
            __rvm_file_load_env_and_trust "$1" "env-";
            _bundle_install="$( \command \tr -d '\r' <"$1" | __rvm_sed -n '/^ruby-bundle-install=/ {s/ruby-bundle-install=//;p;}' )";
            if [[ -n "${_bundle_install}" ]]; then
                if [[ -f "${_bundle_install}" ]]; then
                    __gemfile="${_bundle_install}";
                else
                    __gemfile="${1%/*}/Gemfile";
                fi;
            fi
        ;;
        */Gemfile)
            __rvm_ensure_is_a_function;
            rvm_current_rvmrc="$1";
            rvm_ruby_string="$( \command \tr -d '\r' <"$1" | __rvm_sed -n '/^#ruby=/ {s/#ruby=//;p;}' | tail -n 1 )";
            [[ -n "${rvm_ruby_string}" ]] || { 
                rvm_ruby_string="$(
          \command \tr -d '\r' <"$1" |
          __rvm_sed -n "s/[[:space:]]+rescue[[:space:]]+nil$//; /^\s*ruby[[:space:](]/ {s/^\s*ruby//; s/[[:space:]()'\"]//g; p;}" |
          \tail -n 1
        )";
                [[ -n "${rvm_ruby_string}" ]] || return 2;
                rvm_ruby_string="${rvm_ruby_string%%#*}";
                rvm_ruby_string="${rvm_ruby_string/,:engine=>/-}";
                rvm_ruby_string="${rvm_ruby_string/,engine:/-}";
                rvm_ruby_string="${rvm_ruby_string/,:engine_version=>[^,]*/}";
                rvm_ruby_string="${rvm_ruby_string/,engine_version:[^,]*/}";
                rvm_ruby_string="${rvm_ruby_string/,:patchlevel=>/-p}";
                rvm_ruby_string="${rvm_ruby_string/,patchlevel:/-p}"
            };
            rvm_gemset_name="$( \command \tr -d '\r' <"$1" | __rvm_sed -n '/^#ruby-gemset=/ {s/#ruby-gemset=//;p;}' | tail -n 1 )";
            if [[ -z "${rvm_gemset_name:-}" && -f "${1%/*}/.ruby-gemset" ]]; then
                rvm_gemset_name="$( \command \tr -d '\r' <"${1%/*}/.ruby-gemset" )";
            fi;
            __rvmrc_warning_display_for_Gemfile "$1";
            rvm_create_flag=1 __rvm_use || return 3;
            __rvm_file_load_env_and_trust "$1" "#ruby-env-";
            __gemfile="$1"
        ;;
        */.ruby-version | */.rbfu-version | */.rbenv-version)
            __rvm_ensure_is_a_function;
            rvm_current_rvmrc="$1";
            rvm_ruby_string="$( \command \tr -d '\r' <"$1" )";
            if [[ -z "${rvm_ruby_string}" ]]; then
                return 2;
            fi;
            if [[ -f "${1%/*}/.ruby-gemset" ]]; then
                rvm_gemset_name="$( \command \tr -d '\r' <"${1%/*}/.ruby-gemset" )";
            else
                rvm_gemset_name="";
            fi;
            rvm_create_flag=1 __rvm_use || return 3;
            __rvm_file_load_env_and_trust "${1%/*}/.ruby-env";
            __rvm_file_load_env_and_trust "${1%/*}/.rbenv-vars";
            __gemfile="${1%/*}/Gemfile"
        ;;
        *)
            rvm_error "Unsupported file format for '$1'";
            return 1
        ;;
    esac;
    __rvm_file_set_env;
    if [[ "${rvm_autoinstall_bundler_flag:-0}" == 1 && -n "${__gemfile:-}" && -f "${__gemfile:-}" ]]; then
        __rvm_which bundle > /dev/null 2>&1 || gem install --remote bundler;
        bundle install --gemfile="${__gemfile}" | __rvm_grep -vE '^Using|Your bundle is complete';
    fi
}
__rvm_load_rvmrc () 
{ 
    \typeset _file;
    \typeset -a rvm_rvmrc_files;
    if (( ${rvm_ignore_rvmrc:=0} == 1 )); then
        return 0;
    fi;
    [[ -n "${rvm_stored_umask:-}" ]] || export rvm_stored_umask=$(umask);
    rvm_rvmrc_files=("/etc/rvmrc" "$HOME/.rvmrc");
    if [[ -n "${rvm_prefix:-}" ]] && ! [[ "$HOME/.rvmrc" -ef "${rvm_prefix}/.rvmrc" ]]; then
        rvm_rvmrc_files+=("${rvm_prefix}/.rvmrc");
    fi;
    for _file in "${rvm_rvmrc_files[@]}";
    do
        if [[ -s "$_file" ]]; then
            if __rvm_grep '^\s*rvm .*$' "$_file" > /dev/null 2>&1; then
                rvm_error "
$_file is for rvm settings only.
rvm CLI may NOT be called from within $_file.
Skipping the loading of $_file
";
                return 1;
            else
                source "$_file";
            fi;
        fi;
    done;
    return 0
}
__rvm_log_command () 
{ 
    \typeset name message _command_start _command_name;
    \typeset -a _command;
    name="${1:-}";
    message="${2:-}";
    shift 2;
    _command=("$@");
    _command_start="$1";
    while (( $# )) && [[ "$1" == *"="* ]]; do
        shift;
    done;
    _command_name="$1";
    [[ "${_command_start}" != *"="* ]] || _command=("env" "${_command[@]}");
    if __function_on_stack __rvm_log_command_internal; then
        __rvm_log_command_simple "$@" || return $?;
    else
        __rvm_log_command_internal "$@" || return $?;
    fi
}
__rvm_log_command_caclulate_log_file_name () 
{ 
    [[ -n "${rvm_log_timestamp:-}" ]] || __rvm_log_command_caclulate_log_timestamp;
    [[ -n "${rvm_log_filesystem:-}" ]] || __rvm_log_command_caclulate_log_filesystem;
    [[ -n "${rvm_log_namelen:-}" ]] || __rvm_log_command_caclulate_log_namelen;
    name="${name//[ \/]/_}";
    _log="${rvm_log_path}/${rvm_log_timestamp}${rvm_ruby_string:+_}${rvm_ruby_string:-}/${name}";
    if [[ -n "${ZSH_VERSION:-}" ]]; then
        _log="${_log[0,${rvm_log_namelen}]}.log";
    else
        _log="${_log:0:${rvm_log_namelen}}.log";
    fi
}
__rvm_log_command_caclulate_log_filesystem () 
{ 
    export rvm_log_filesystem="$(
    __rvm_mount 2>/dev/null | __rvm_awk -v rvm_path=$rvm_path '
      BEGIN{longest=""; fstype=""}
      {if (index(rvm_path,$3)==1 && length($3)>length(longest)){longest=$3; fstype=$5}}
      END{print fstype}
    '
  )";
    rvm_debug "Log filesystem: ${rvm_log_filesystem}"
}
__rvm_log_command_caclulate_log_namelen () 
{ 
    case "${rvm_log_filesystem}" in 
        ecryptfs)
            export rvm_log_namelen=138
        ;;
        *)
            export rvm_log_namelen=250
        ;;
    esac;
    rvm_debug "Log max name length: ${rvm_log_namelen}"
}
__rvm_log_command_caclulate_log_timestamp () 
{ 
    export rvm_log_timestamp="$(__rvm_date "+%s")";
    rvm_debug "Log prefix: ${rvm_log_path}/${rvm_log_timestamp}${rvm_ruby_string:+_}${rvm_ruby_string:-}/"
}
__rvm_log_command_debug () 
{ 
    printf "%b" "[$(__rvm_date +'%Y-%m-%d %H:%M:%S')] ${_command_name}\n";
    if is_a_function "${_command_name}"; then
        \typeset -f "${_command_name}";
    fi;
    printf "%b" "current path: $PWD\n";
    env | __rvm_grep -E '^GEM_HOME=|^GEM_PATH=|^PATH=';
    printf "%b" "command(${#_command[@]}): ${_command[*]}\n"
}
__rvm_log_command_internal () 
{ 
    \typeset _log;
    (( ${rvm_niceness:-0} == 0 )) || _command=(nice -n $rvm_niceness "${_command[@]}");
    __rvm_log_command_caclulate_log_file_name;
    rvm_debug "Log file: ${_log}";
    [[ -d "${_log%\/*}" ]] || \command \mkdir -p "${_log%\/*}";
    [[ -f "${_log}" ]] || \command \rm -f "${_log}";
    __rvm_log_command_debug | tee "${_log}" | rvm_debug_stream;
    __rvm_log_dotted "${_log}" "$message" "${_command[@]}" || { 
        \typeset result=$?;
        \typeset __show_lines="${rvm_show_log_lines_on_error:-0}";
        rvm_error "Error running '${_command[*]}',";
        case "${__show_lines}" in 
            0)
                rvm_error "please read ${_log}"
            ;;
            all)
                rvm_error "content of log ${_log}";
                cat "${_log}" 1>&6
            ;;
            *)
                rvm_error "showing last ${__show_lines} lines of ${_log}";
                tail -n "${__show_lines}" "${_log}" 1>&6
            ;;
        esac;
        return ${result}
    }
}
__rvm_log_command_simple () 
{ 
    __rvm_log_command_debug;
    rvm_log "$message";
    "$@" || return $?
}
__rvm_log_dotted () 
{ 
    \typeset __log_file __message __iterator __result __local_rvm_trace_flag;
    __log_file="$1";
    __message="$2";
    shift 2;
    __result=0;
    __local_rvm_trace_flag=${rvm_trace_flag:-0};
    if (( ${rvm_trace_flag:-0} )); then
        { 
            set -x;
            "$@" 2>&1 | tee -a "${__log_file}";
            __rvm_check_pipestatus ${PIPESTATUS[@]} ${pipestatus[@]} || __result=$?;
            (( __local_rvm_trace_flag > 0 )) || set +x
        } 1>&2;
    else
        if [[ -n "${ZSH_VERSION:-}" ]]; then
            rvm_log "${__message} - please wait";
            { 
                set -x;
                "$@" > "${__log_file}" 2>&1 || __result=$?;
                (( __local_rvm_trace_flag > 0 )) || set +x
            } 2> /dev/null;
        else
            { 
                set -x;
                "$@" 2>&1 | tee -a "${__log_file}" | __rvm_dotted "${__message}";
                __rvm_check_pipestatus ${PIPESTATUS[@]} ${pipestatus[@]} || __result=$?;
                (( __local_rvm_trace_flag > 0 )) || set +x
            } 2> /dev/null;
        fi;
    fi;
    return $__result
}
__rvm_make () 
{ 
    \make "$@" || return $?
}
__rvm_md5_calculate () 
{ 
    rvm_debug "Calculate md5 checksum for $@";
    \typeset _sum;
    if builtin command -v md5 > /dev/null 2>&1; then
        _sum=$(md5 "$@");
        echo ${_sum##* };
        return 0;
    else
        if builtin command -v md5sum > /dev/null 2>&1; then
            _sum=$(md5sum "$@");
            echo ${_sum%% *};
            return 0;
        else
            if builtin command -v gmd5sum > /dev/null 2>&1; then
                _sum=$(gmd5sum "$@");
                echo ${_sum%% *};
                return 0;
            else
                for _path in /usr/gnu/bin /opt/csw/bin /sbin /bin /usr/bin /usr/sbin;
                do
                    if [[ -x "${_path}/md5" ]]; then
                        _sum=$(${_path}/md5 "$@");
                        echo ${_sum##* };
                        return 0;
                    else
                        if [[ -x "${_path}/md5sum" ]]; then
                            _sum=$(${_path}/md5sum "$@");
                            echo ${_sum%% *};
                            return 0;
                        else
                            if [[ -x "${_path}/gmd5sum" ]]; then
                                _sum=$(${_path}/gmd5sum "$@");
                                echo ${_sum%% *};
                                return 0;
                            fi;
                        fi;
                    fi;
                done;
            fi;
        fi;
    fi;
    rvm_error "Neither of md5sum, md5, gmd5sum found in the PATH";
    return 1
}
__rvm_md5_for_contents () 
{ 
    if builtin command -v md5 > /dev/null; then
        md5 | __rvm_awk '{print $1}';
    else
        if builtin command -v md5sum > /dev/null; then
            md5sum | __rvm_awk '{print $1}';
        else
            if builtin command -v openssl > /dev/null; then
                openssl md5 | __rvm_awk '{print $1}';
            else
                return 1;
            fi;
        fi;
    fi;
    true
}
__rvm_mount () 
{ 
    \mount "$@" || return $?
}
__rvm_nuke_rvm_variables () 
{ 
    unset rvm_head_flag $(env | __rvm_awk -F= '/^rvm_/{print $1" "}')
}
__rvm_package_create () 
{ 
    rvm_debug __rvm_package_create:$#: "$@";
    case "$1" in 
        *.tar.bz2)
            if [[ -z "${3:-}" ]]; then
                __rvm_tar cjf "$1" "$2";
            else
                __rvm_tar cjf "$1" -C "$2" "$3";
            fi
        ;;
        *.tar.gz | *.tgz)
            if [[ -z "${3:-}" ]]; then
                __rvm_tar czf "$1" "$2";
            else
                __rvm_tar czf "$1" -C "$2" "$3";
            fi
        ;;
        *)
            return 199
        ;;
    esac
}
__rvm_package_extract () 
{ 
    rvm_debug __rvm_package_extract:$#: "$@";
    \typeset __tempdir __path __file __return;
    __return=0;
    __tempdir="$( TMPDIR="${rvm_tmp_path}" mktemp -d -t rvm-tmp.XXXXXXXXX )";
    __rvm_package_extract_run "$1" "$__tempdir" || __return=$?;
    if (( __return == 0 )); then
        for __path in "$__tempdir"/*;
        do
            __file="${__path##*/}";
            if [[ -n "${__file}" && -e "$2/${__file}" ]]; then
                \command \rm -rf "$2/${__file}" || __return=$?;
            fi;
            \command \mv -f "${__path}" "$2/" || __return=$?;
        done;
    fi;
    if [[ -n "$__tempdir" ]]; then
        \command \rm -rf "$__tempdir";
    fi;
    return $__return
}
__rvm_package_extract_run () 
{ 
    if [[ " ${rvm_tar_options:-} " != *" --no-same-owner "* ]] && __rvm_tar --help 2>&1 | __rvm_grep -- --no-same-owner > /dev/null; then
        rvm_tar_options="${rvm_tar_options:-}${rvm_tar_options:+ }--no-same-owner";
    fi;
    [[ -d "$2" ]] || mkdir -p "$2";
    case "$1" in 
        *.zip)
            unzip -q -o "$1" -d "$2"
        ;;
        *.tar.bz2)
            if [[ -n "$ZSH_VERSION" ]]; then
                __rvm_tar xjf "$1" -C "$2" ${=rvm_tar_options:-};
            else
                __rvm_tar xjf "$1" -C "$2" ${rvm_tar_options:-};
            fi
        ;;
        *.tar.gz | *.tgz)
            if [[ -n "$ZSH_VERSION" ]]; then
                __rvm_tar xzf "$1" -C "$2" ${=rvm_tar_options:-};
            else
                __rvm_tar xzf "$1" -C "$2" ${rvm_tar_options:-};
            fi
        ;;
        *)
            return 199
        ;;
    esac && __rvm_fix_group_permissions "$2"/* || return $?
}
__rvm_package_list () 
{ 
    rvm_debug __rvm_package_list:$#: "$@";
    case "$1" in 
        *.zip)
            unzip -Z -1 "$1"
        ;;
        *.tar.bz2)
            __rvm_tar tjf "$1"
        ;;
        *.tar.gz | *.tgz)
            __rvm_tar tzf "$1"
        ;;
        *)
            return 199
        ;;
    esac
}
__rvm_pager_or_cat_v () 
{ 
    eval "${PAGER:-\command \cat} '$1'"
}
__rvm_parse_args () 
{ 
    \typeset _string;
    export rvm_ruby_string;
    rvm_action="${rvm_action:-""}";
    rvm_parse_break=0;
    if [[ " $* " == *" --trace "* ]]; then
        echo "$@";
        __rvm_print_headline;
    fi;
    while [[ -n "$next_token" ]]; do
        rvm_token="$next_token";
        if (( $# > 0 )); then
            next_token="$1";
            shift;
        else
            next_token="";
        fi;
        case "$rvm_token" in 
            [0-9a-zA-ZuU]* | @*)
                case "$rvm_token" in 
                    use)
                        rvm_action="$rvm_token";
                        rvm_verbose_flag=1;
                        __rvm_file_env_check_unload;
                        if [[ -n "${next_token:-}" && ! -d "${next_token:-}" && "${next_token:-}" != "-"* && "${next_token:-}" != "@"* ]]; then
                            rvm_ruby_interpreter="$next_token";
                            rvm_ruby_string="$next_token";
                            rvm_ruby_strings="$next_token";
                            next_token="${1:-}";
                            (( $# == 0 )) || shift;
                        else
                            if [[ -z "${next_token:-}" ]] && __rvm_project_dir_check .; then
                                __rvm_rvmrc_tools try_to_read_ruby . || __rvm_parse_args_error_finding_project_file;
                            fi;
                        fi
                    ;;
                    install | uninstall | reinstall | try_install)
                        export ${rvm_token}_flag=1;
                        rvm_action=$rvm_token
                    ;;
                    gemset)
                        rvm_action=$rvm_token;
                        rvm_ruby_args=();
                        __rvm_parse_args_find_known_flags rvm_ruby_args "$next_token" "$@";
                        : rvm_ruby_args:${#rvm_ruby_args[@]}:${rvm_ruby_args[*]}:;
                        next_token="${rvm_ruby_args[__array_start]}";
                        rvm_gemset_name="${rvm_ruby_args[__array_start+1]}";
                        case "${next_token:-help}" in 
                            help)
                                true
                            ;;
                            use | delete)
                                [[ "delete" != "$next_token" ]] || rvm_delete_flag=1;
                                [[ "use" != "$next_token" ]] || rvm_action+="_$next_token";
                                case "$rvm_gemset_name" in 
                                    *${rvm_gemset_separator:-"@"}*)
                                        rvm_ruby_string="${rvm_gemset_name%%${rvm_gemset_separator:-"@"}*}";
                                        rvm_gemset_name="${rvm_gemset_name##*${rvm_gemset_separator:-"@"}}";
                                        if [[ "${rvm_ruby_string:-""}" != "${rvm_gemset_name:-""}" ]]; then
                                            rvm_ruby_string="$rvm_ruby_string${rvm_gemset_separator:-"@"}$rvm_gemset_name";
                                        fi;
                                        rvm_ruby_gem_home="$rvm_ruby_gem_home${rvm_gemset_separator:-"@"}$rvm_gemset_name"
                                    ;;
                                    "")
                                        rvm_error "Gemset was not given.\n  Usage:\n    rvm gemset $rvm_gemset_name <gemsetname>\n";
                                        return 1
                                    ;;
                                esac
                            ;;
                        esac;
                        rvm_parse_break=1
                    ;;
                    gemdir | gempath | gemhome)
                        rvm_ruby_args=("$rvm_token");
                        rvm_action="gemset";
                        rvm_gemdir_flag=1;
                        if [[ "system" == "$next_token" ]]; then
                            rvm_system_flag=1;
                            next_token="${1:-}";
                            (( $# == 0 )) || shift;
                        fi;
                        if [[ "user" == "$next_token" ]]; then
                            rvm_user_flag=1;
                            next_token="${1:-}";
                            (( $# == 0 )) || shift;
                        fi
                    ;;
                    pkg)
                        rvm_action="$rvm_token";
                        __rvm_parse_args_find_known_flags rvm_ruby_args "$next_token" "$@";
                        rvm_parse_break=1
                    ;;
                    do | exec)
                        if [[ -z "$next_token" ]]; then
                            rvm_action="error";
                            rvm_error_message="'rvm $rvm_token' must be followed by arguments.";
                            break;
                        fi;
                        rvm_action="do";
                        rvm_ruby_args=("$next_token" "$@");
                        rvm_parse_break=1
                    ;;
                    gem | rake | ruby)
                        [[ "$rvm_token" == "ruby" ]] && case $rvm_action in 
                            install | reinstall | use | remove)
                                rvm_ruby_string=ruby;
                                rvm_ruby_strings=ruby;
                                continue
                            ;;
                        esac;
                        rvm_action=error;
                        rvm_error_message="Please note that \`rvm $rvm_token ...\` was removed, try \`$rvm_token $next_token $*\` or \`rvm all do $rvm_token $next_token $*\` instead."
                    ;;
                    fetch | version | remote_version | reset | debug | reload | update | monitor | notes | implode | seppuku | env | unexport | automount | prepare)
                        rvm_action=$rvm_token
                    ;;
                    doctor)
                        rvm_action=notes
                    ;;
                    mount)
                        rvm_action=$rvm_token;
                        while [[ -n "${next_token:-}" ]] && [[ -x "${next_token:-}" || -d "${next_token:-}" || "${next_token:-}" == http* || "${next_token:-}" == *tar.bz2 || "${next_token:-}" == *tar.gz ]]; do
                            rvm_ruby_args=("$next_token" "${rvm_ruby_args[@]}");
                            next_token="${1:-}";
                            (( $# == 0 )) || shift;
                        done
                    ;;
                    rm | remove)
                        rvm_action="remove";
                        rvm_remove_flag=1
                    ;;
                    rtfm | RTFM | rvmrc | help | inspect | list | ls | info | strings | get | current | docs | alias | rubygems | cleanup | tools | disk-usage | snapshot | repair | migrate | downgrade | upgrade | cron | group | switch | which | config-get | requirements | autolibs | osx-ssl-certs | fix-permissions)
                        case "$rvm_token" in 
                            downgrade)
                                rvm_action="upgrade"
                            ;;
                            ls)
                                rvm_action="list"
                            ;;
                            RTFM)
                                rvm_action="rtfm"
                            ;;
                            *)
                                rvm_action="$rvm_token"
                            ;;
                        esac;
                        rvm_ruby_args=();
                        __rvm_parse_args_find_known_flags rvm_ruby_args "$next_token" "$@";
                        rvm_parse_break=1
                    ;;
                    user)
                        rvm_action="tools";
                        rvm_ruby_args=("$rvm_token" "$next_token" "$@");
                        rvm_parse_break=1
                    ;;
                    load-rvmrc)
                        rvm_action="rvmrc";
                        rvm_ruby_args=("load" "$next_token" "$@");
                        rvm_parse_break=1
                    ;;
                    specs | tests)
                        rvm_action="rake";
                        rvm_ruby_args=("${rvm_token/%ss/s}")
                    ;;
                    export)
                        if [[ -n "$next_token" ]]; then
                            \typeset -a ___args;
                            ___args=("$next_token" "$@");
                            rvm_export_args="${___args[*]}";
                            rvm_action="export";
                            rvm_parse_break=1;
                        else
                            rvm_action="error";
                            rvm_error_message="rvm export must be followed by a NAME=VALUE argument";
                        fi
                    ;;
                    alt*)
                        rvm_action="help";
                        rvm_ruby_args=("alt.md");
                        rvm_parse_break=1
                    ;;
                    wrapper)
                        rvm_action="wrapper";
                        rvm_ruby_string="$next_token";
                        rvm_wrapper_name="$1";
                        (( $# == 0 )) || shift;
                        rvm_ruby_args=("$@");
                        rvm_parse_break=1
                    ;;
                    in)
                        rvm_token="${next_token}";
                        next_token="${1:-}";
                        (( $# == 0 )) || shift;
                        export rvm_in_flag="$rvm_token";
                        __rvm_project_dir_check "$rvm_token" && __rvm_rvmrc_tools try_to_read_ruby $rvm_token || __rvm_parse_args_error_finding_project_file
                    ;;
                    usage)
                        rvm_action="deprecated";
                        rvm_error_message="This command has been deprecated. Use ${rvm_notify_clr:-}rvm help${rvm_error_clr:-} instead.";
                        rvm_parse_break=1
                    ;;
                    *,*)
                        rvm_ruby_strings="$rvm_token";
                        [[ -n "${rvm_action:-""}" ]] || rvm_action="ruby"
                    ;;
                    ${rvm_gemset_separator:-"@"}*)
                        rvm_action="${rvm_action:-use}";
                        rvm_gemset_name="${rvm_token#${rvm_gemset_separator:-"@"}}";
                        rvm_ruby_string="${rvm_ruby_string:-${GEM_HOME##*/}}";
                        rvm_ruby_string="${rvm_ruby_string%%${rvm_gemset_separator:-"@"}*}";
                        rvm_ruby_strings="${rvm_ruby_string}${rvm_gemset_separator:-"@"}${rvm_gemset_name}"
                    ;;
                    *${rvm_gemset_separator:-"@"}*)
                        rvm_verbose_flag=1;
                        rvm_action="${rvm_action:-use}";
                        rvm_gemset_name="${rvm_token/*${rvm_gemset_separator:-"@"}/}";
                        rvm_ruby_string="$rvm_token";
                        rvm_ruby_strings="$rvm_token"
                    ;;
                    *+*)
                        rvm_action="${rvm_action:-use}";
                        rvm_ruby_alias="${rvm_token/*+/}";
                        rvm_ruby_string="${rvm_token/+*/}";
                        rvm_ruby_strings="$rvm_ruby_string"
                    ;;
                    *-* | +([0-9]).+([0-9])*)
                        rvm_verbose_flag=1;
                        rvm_action="${rvm_action:-use}";
                        rvm_ruby_string="$rvm_token";
                        rvm_ruby_strings="$rvm_token"
                    ;;
                    opal* | jruby* | ree* | macruby* | rbx* | rubinius* | mruby | ironruby* | default* | maglev* | topaz* | ruby* | system | default | all)
                        rvm_action="${rvm_action:-use}";
                        rvm_ruby_interpreter="$rvm_token";
                        rvm_ruby_string="$rvm_token";
                        rvm_ruby_strings="$rvm_token"
                    ;;
                    kiji* | tcs* | jamesgolick*)
                        rvm_error_message="The $rvm_token was removed from RVM, use: rvm install ruby-head-<name> --url https://github.com/github/ruby.git --branch 2.1";
                        rvm_action="error"
                    ;;
                    old)
                        case "${rvm_action:-action-missing}" in 
                            remove)
                                rvm_ruby_strings="old:${next_token:-}";
                                next_token="${1:-}";
                                (( $# == 0 )) || shift
                            ;;
                            action-missing)
                                rvm_error_message="what do you want to do with old rubies? rvm can only remove old rubies.";
                                rvm_action="error"
                            ;;
                            *)
                                rvm_error_message="rvm can not $rvm_action old rubies, rvm can only remove old rubies.";
                                rvm_action="error"
                            ;;
                        esac
                    ;;
                    *.rb)
                        rvm_ruby_args=("$rvm_token");
                        rvm_ruby_file="$rvm_token";
                        if [[ -z "${rvm_action:-""}" || "$rvm_action" == "use" ]]; then
                            rvm_action="ruby";
                        fi
                    ;;
                    *.gems)
                        rvm_file_name="${rvm_token}"
                    ;;
                    "")
                        rvm_action="error";
                        rvm_error_message="Unrecognized command line argument(s): $@"
                    ;;
                    *)
                        if [[ "gemset" == "$rvm_action" ]]; then
                            rvm_gemset_name="${rvm_token/.gems/}";
                            rvm_file_name="$rvm_gemset_name.gems";
                        else
                            if [[ -f "$rvm_rubies_path/$rvm_token" || -L "$rvm_rubies_path/$rvm_token" ]]; then
                                rvm_ruby_string=$rvm_token;
                                rvm_ruby_strings="$rvm_token";
                                rvm_action="${rvm_action:-use}";
                            else
                                if [[ -d "$rvm_token" ]] || __rvm_project_dir_check "$rvm_token"; then
                                    __rvm_rvmrc_tools try_to_read_ruby $rvm_token || __rvm_parse_args_error_finding_project_file;
                                else
                                    rvm_action="error";
                                    rvm_error_message="Unrecognized command line argument: $rvm_token";
                                fi;
                            fi;
                        fi
                    ;;
                esac
            ;;
            -*)
                case "$rvm_token" in 
                    -S)
                        rvm_action="ruby";
                        rvm_ruby_args=("$rvm_token" "$next_token" "$@");
                        rvm_parse_break=1
                    ;;
                    -e)
                        rvm_action="ruby";
                        IFS="\n";
                        rvm_ruby_args=("$rvm_token" "'$next_token $@'");
                        IFS=" ";
                        rvm_parse_break=1
                    ;;
                    -v | --version)
                        if [[ -z "$next_token" ]]; then
                            rvm_action="version";
                        else
                            rvm_ruby_version="$next_token";
                            next_token="${1:-}";
                            (( $# == 0 )) || shift;
                        fi
                    ;;
                    -n | --name)
                        rvm_ruby_name="$next_token";
                        next_token="${1:-}";
                        (( $# == 0 )) || shift
                    ;;
                    --branch)
                        rvm_ruby_repo_branch="$next_token";
                        next_token="${1:-}";
                        (( $# == 0 )) || shift;
                        rvm_disable_binary_flag=1
                    ;;
                    --repository | --repo | --url)
                        rvm_ruby_repo_url="$next_token";
                        next_token="${1:-}";
                        (( $# == 0 )) || shift;
                        rvm_disable_binary_flag=1
                    ;;
                    -r | --remote | --binary | --latest-binary)
                        rvm_remote_flag=1;
                        if [[ "$rvm_token" == "--latest-binary" ]]; then
                            rvm_fuzzy_flag=1;
                        fi;
                        while [[ -n "${next_token:-}" ]] && [[ "${next_token:-}" == http* || "${next_token:-}" == *tar.bz2 || "${next_token:-}" == *tar.gz || "${next_token:-}" == *":"* ]]; do
                            rvm_ruby_args=("${rvm_ruby_args[@]}" "$next_token");
                            next_token="${1:-}";
                            (( $# == 0 )) || shift;
                        done
                    ;;
                    --ree-options)
                        if [[ -n "$next_token" ]]; then
                            __rvm_custom_separated_array rvm_ree_options , "${next_token}";
                            next_token="${1:-}";
                            (( $# == 0 )) || shift;
                        else
                            rvm_action="error";
                            rvm_error_message="--ree-options *must* be followed by... well... comma,separated,list,of,options.";
                        fi
                    ;;
                    --patches | --patch)
                        __rvm_custom_separated_array rvm_patch_names , "$next_token";
                        next_token="${1:-}";
                        (( $# == 0 )) || shift;
                        rvm_patch_original_pwd="$PWD";
                        rvm_disable_binary_flag=1
                    ;;
                    --arch | --archflags)
                        rvm_architectures+=("${next_token#-arch }");
                        next_token="${1:-}";
                        (( $# == 0 )) || shift;
                        rvm_disable_binary_flag=1
                    ;;
                    --with-arch=*)
                        rvm_architectures+=("${rvm_token#--with-arch=}");
                        rvm_disable_binary_flag=1
                    ;;
                    --32 | --64)
                        rvm_architectures+=("${rvm_token#--}");
                        rvm_disable_binary_flag=1
                    ;;
                    --universal)
                        rvm_architectures+=("32" "64");
                        rvm_disable_binary_flag=1
                    ;;
                    --bin)
                        rvm_bin_path="$next_token";
                        next_token="${1:-}";
                        (( $# == 0 )) || shift
                    ;;
                    --rdoc | --yard)
                        rvm_docs_type="$rvm_token";
                        rvm_docs_type
                    ;;
                    -f | --file)
                        rvm_action="ruby";
                        rvm_ruby_file="$next_token";
                        next_token="${1:-}";
                        (( $# == 0 )) || shift
                    ;;
                    --passenger)
                        rvm_log "NOTE: If you are using Passenger 3 you no longer need the passenger_ruby,\nuse the wrapper script for your ruby instead (see 'rvm wrapper')";
                        rvm_wrapper_name="${rvm_token/--/}"
                    ;;
                    --editor)
                        rvm_wrapper_name="${rvm_token/--/}"
                    ;;
                    --symlink)
                        rvm_warn "--symlink has been removed, please see 'rvm wrapper'.";
                        next_token="${1:-}";
                        (( $# == 0 )) || shift
                    ;;
                    -h | --help)
                        rvm_action=help
                    ;;
                    -l | --level)
                        rvm_ruby_patch_level="p$next_token";
                        next_token="${1:-}";
                        (( $# == 0 )) || shift
                    ;;
                    --sha | --make | --make-install)
                        rvm_token=${rvm_token#--};
                        rvm_token=${rvm_token//-/_};
                        export "rvm_ruby_${rvm_token}"="$next_token";
                        next_token="${1:-}";
                        rvm_disable_binary_flag=1;
                        (( $# == 0 )) || shift
                    ;;
                    --nice | --sdk | --autoconf-flags | --proxy)
                        rvm_token=${rvm_token#--};
                        rvm_token=${rvm_token//-/_};
                        export "rvm_${rvm_token}"="$next_token";
                        next_token="${1:-}";
                        (( $# == 0 )) || shift
                    ;;
                    --disable-llvm | --disable-jit)
                        rvm_llvm_flag=0
                    ;;
                    --enable-llvm | --enable-jit)
                        rvm_llvm_flag=1
                    ;;
                    --install)
                        rvm_install_on_use_flag=1
                    ;;
                    --autolibs=*)
                        export rvm_autolibs_flag="${rvm_token#*=}"
                    ;;
                    --color=*)
                        rvm_pretty_print_flag=${rvm_token#--color=}
                    ;;
                    --pretty)
                        rvm_pretty_print_flag=auto
                    ;;
                    --1.8 | --1.9 | --2.0 | --2.1 | --18 | --19 | --20 | --21)
                        rvm_token=${rvm_token#--};
                        rvm_token=${rvm_token//\./};
                        export "rvm_${rvm_token}_flag"=1;
                        rvm_disable_binary_flag=1
                    ;;
                    --rvmrc | --versions-conf | --ruby-version)
                        rvm_token=${rvm_token#--};
                        rvm_token=${rvm_token//-/_};
                        export rvm_rvmrc_flag="${rvm_token}"
                    ;;
                    --list-missing-packages)
                        export rvm_list_missing_packages_flag=1;
                        export rvm_quiet_flag=1
                    ;;
                    --list-undesired-packages)
                        export rvm_list_undesired_packages_flag=1;
                        export rvm_quiet_flag=1
                    ;;
                    --list-installed-packages)
                        export rvm_list_installed_packages_flag=1;
                        export rvm_quiet_flag=1
                    ;;
                    --list-all-packages)
                        export rvm_list_missing_packages_flag=1;
                        export rvm_list_undesired_packages_flag=1;
                        export rvm_list_installed_packages_flag=1;
                        export rvm_quiet_flag=1
                    ;;
                    --head | --static | --self | --gem | --reconfigure | --default | --force | --export | --summary | --latest | --yaml | --json | --archive | --shebang | --path | --cron | --tail | --delete | --verbose | --import | --sticky | --create | --gems | --docs | --skip-autoreconf | --force-autoconf | --auto-dotfiles | --autoinstall-bundler | --disable-binary | --ignore-gemsets | --skip-gemsets | --debug | --quiet | --silent | --skip-openssl | --fuzzy | --quiet-curl | --skip-pristine | --dynamic-extensions)
                        rvm_token=${rvm_token#--};
                        rvm_token=${rvm_token//-/_};
                        export "rvm_${rvm_token}_flag"=1
                    ;;
                    --no-docs)
                        rvm_token=${rvm_token#--no-};
                        rvm_token=${rvm_token//-/_};
                        export "rvm_${rvm_token}_flag"=0
                    ;;
                    --auto)
                        export "rvm_auto_dotfiles_flag"=1;
                        rvm_warn "Warning, --auto is deprecated in favor of --auto-dotfiles."
                    ;;
                    --rubygems)
                        rvm_token=${rvm_token#--};
                        rvm_token=${rvm_token//-/_};
                        export "rvm_${rvm_token}_version"="$next_token";
                        next_token="${1:-}";
                        (( $# == 0 )) || shift
                    ;;
                    --dump-environment | --max-time)
                        rvm_token=${rvm_token#--};
                        rvm_token=${rvm_token//-/_};
                        export "rvm_${rvm_token}_flag"="$next_token";
                        next_token="${1:-}";
                        (( $# == 0 )) || shift
                    ;;
                    --verify-downloads)
                        rvm_token=${rvm_token#--};
                        rvm_token=${rvm_token//-/_};
                        export "rvm_${rvm_token}_flag_cli"="$next_token";
                        next_token="${1:-}";
                        (( $# == 0 )) || shift
                    ;;
                    --clang)
                        export CC=clang;
                        export CXX=clang++;
                        rvm_disable_binary_flag=1
                    ;;
                    -M)
                        if [[ -n "$next_token" ]]; then
                            __rvm_custom_separated_array rvm_make_flags , "${next_token}";
                            next_token="${1:-}";
                            (( $# == 0 )) || shift;
                            rvm_disable_binary_flag=1;
                        else
                            rvm_action="error";
                            rvm_error_message="--make *must* be followed by make flags.";
                        fi
                    ;;
                    -j)
                        if [[ -n "$next_token" ]]; then
                            rvm_make_flags+=(-j$next_token);
                            next_token="${1:-}";
                            (( $# == 0 )) || shift;
                        else
                            rvm_action="error";
                            rvm_error_message="-j *must* be followed by an integer (normally the # of CPU's in your machine).";
                        fi
                    ;;
                    --with-rubies)
                        rvm_ruby_strings="$next_token";
                        next_token="${1:-}";
                        (( $# == 0 )) || shift
                    ;;
                    -C | --configure)
                        if [[ -n "$next_token" ]]; then
                            __rvm_custom_separated_array rvm_configure_flags , "${next_token}";
                            next_token="${1:-}";
                            (( $# == 0 )) || shift;
                            rvm_disable_binary_flag=1;
                        else
                            rvm_action="error";
                            rvm_error_message="--configure *must* be followed by configure flags.";
                        fi
                    ;;
                    -E | --env)
                        if [[ -n "$next_token" ]]; then
                            __rvm_custom_separated_array rvm_configure_env , "${next_token}";
                            next_token="${1:-}";
                            (( $# == 0 )) || shift;
                            rvm_disable_binary_flag=1;
                        else
                            rvm_action="error";
                            rvm_error_message="--configure *must* be followed by configure flags.";
                        fi
                    ;;
                    --movable)
                        rvm_movable_flag=1;
                        rvm_disable_binary_flag=1
                    ;;
                    --with-* | --without-* | --enable-* | --disable-*)
                        rvm_configure_flags+=("$rvm_token");
                        rvm_disable_binary_flag=1
                    ;;
                    --trace)
                        export rvm_trace_flag=1;
                        if [[ -n "${BASH_VERSION:-}" ]]; then
                            export PS4="+ \$(__rvm_date \"+%s.%N\" 2>/dev/null) \${BASH_SOURCE##\${rvm_path:-}} : \${FUNCNAME[0]:+\${FUNCNAME[0]}()}  \${LINENO} > ";
                        else
                            if [[ -n "${ZSH_VERSION:-}" ]]; then
                                export PS4="+ %* %F{red}%x:%I %F{green}%N:%i%F{white} %_";
                            fi;
                        fi;
                        set -o xtrace
                    ;;
                    --)
                        if [[ "${rvm_action}" == *install ]]; then
                            rvm_configure_flags+=("$next_token" "$@");
                        else
                            rvm_ruby_args=("$next_token" "$@");
                        fi;
                        rvm_disable_binary_flag=1;
                        rvm_parse_break=1
                    ;;
                    *)
                        rvm_action="error";
                        rvm_error_message="Unrecognized command line flag: '$rvm_token'"
                    ;;
                esac
            ;;
            *)
                if [[ -d "$rvm_token" ]] || __rvm_project_dir_check "$rvm_token"; then
                    __rvm_rvmrc_tools try_to_read_ruby "$rvm_token" || __rvm_parse_args_error_finding_project_file;
                else
                    rvm_action="error";
                    rvm_error_message="Unrecognized command line argument(s): '$rvm_token $@'";
                fi
            ;;
        esac;
        if [[ -z "${rvm_action:-""}" && -n "${rvm_ruby_string:-""}" ]]; then
            rvm_action="use";
        fi;
        if [[ "error" == "${rvm_action:-""}" || ${rvm_parse_break:-0} -eq 1 || -n "${rvm_error_message:-""}" ]]; then
            break;
        fi;
    done;
    : rvm_ruby_args:${#rvm_ruby_args[@]}:${rvm_ruby_args[*]}:;
    if [[ -n "${rvm_error_message:-""}" ]]; then
        if [[ "${rvm_action}" == "deprecated" ]]; then
            rvm_error "$rvm_error_message";
        else
            rvm_error "$rvm_error_message";
            rvm_out "Run \`rvm help\` to see usage information";
        fi;
        unset rvm_error_message;
        return 1;
    fi
}
__rvm_parse_args_error_finding_project_file () 
{ 
    unset RVM_PROJECT_PATH;
    case $? in 
        101)
            true
        ;;
        *)
            rvm_error_message="Could not determine which Ruby to use; $rvm_token should contain .rvmrc or .versions.conf or .ruby-version or .rbfu-version or .rbenv-version, or an appropriate line in Gemfile."
        ;;
    esac;
    rvm_action="error"
}
__rvm_parse_args_find_known_flags () 
{ 
    \typeset _args_array_name _temp_var;
    \typeset -a _new_args;
    _args_array_name="$1";
    (( $# == 0 )) || shift;
    _new_args=();
    while (( $# )); do
        case "$1" in 
            --verify-downloads)
                export "rvm_verify_downloads_flag_cli"="${2:-}";
                shift
            ;;
            --force | --verbose | --debug | --quiet | --silent | --create)
                export "rvm_${1#--}_flag=1"
            ;;
            --only-path)
                _temp_var="${1#--}";
                export "rvm_${_temp_var//-/_}_flag=1"
            ;;
            --32 | --64)
                rvm_architectures+=("${1#--}");
                rvm_disable_binary_flag=1
            ;;
            --universal)
                rvm_architectures+=("32" "64");
                rvm_disable_binary_flag=1
            ;;
            --patches | --patch)
                __rvm_custom_separated_array rvm_patch_names , "${2:-}";
                rvm_patch_original_pwd="$PWD";
                rvm_disable_binary_flag=1;
                shift
            ;;
            --autolibs=*)
                export rvm_autolibs_flag="${1#*=}"
            ;;
            --)
                shift;
                _new_args+=("$@");
                shift $#
            ;;
            *)
                _new_args+=("$1")
            ;;
        esac;
        (( $# == 0 )) || shift;
    done;
    eval "${_args_array_name}+=( \"\${_new_args[@]}\" )"
}
__rvm_parse_gems_args () 
{ 
    \typeset gem="${*%%;*}";
    if __rvm_string_match "$gem" "*.gem$"; then
        gem_name="$(basename "${gem/.gem/}" |  __rvm_awk -F'-' '{$NF=NULL;print}')";
        gem_version="$(basename "${gem/.gem/}" |  __rvm_awk -F'-' '{print $NF}' )";
    else
        gem_name="${gem/ */}";
        case "$gem" in 
            *--version*)
                gem_version=$(
          echo "$gem" | __rvm_sed -e 's#.*--version[=]*[ ]*##' | __rvm_awk '{print $1}'
        )
            ;;
            *-v*)
                gem_version=$(
          echo "$gem" | __rvm_sed -e 's#.*-v[=]*[ ]*##' | __rvm_awk '{print $1}'
        )
            ;;
        esac;
    fi
}
__rvm_patch () 
{ 
    \patch "$@" || return $?
}
__rvm_path_match_gem_home_check () 
{ 
    (( ${rvm_silence_path_mismatch_check_flag:-0} == 0 )) || return 0;
    if [[ -n "${GEM_HOME:-}" ]]; then
        case "$PATH:" in 
            $GEM_HOME/bin:*)
                true
            ;;
            *:$GEM_HOME/bin:*)
                __rvm_path_match_gem_home_check_warning "is not at first place"
            ;;
            *)
                __rvm_path_match_gem_home_check_warning "is not available"
            ;;
        esac;
    else
        \typeset __path_to_ruby;
        if __path_to_ruby="$( builtin command -v ruby 2>/dev/null )" && [[ "${__path_to_ruby}" == "${rvm_path}"* ]]; then
            __path_to_ruby="${__path_to_ruby%/bin/ruby}";
            __path_to_ruby="${__path_to_ruby##*/}";
            __rvm_path_match_gem_home_check_warning_missing "${__path_to_ruby}";
        fi;
    fi
}
__rvm_path_match_gem_home_check_warn () 
{ 
    rvm_warn "Warning! PATH is not properly set up, $1.
         Usually this is caused by shell initialization files. Search for 'PATH=...' entries.
         You can also re-add RVM to your profile by running: 'rvm get stable --auto-dotfiles'.
         To fix it temporarily in this shell session run: 'rvm use $2'.
         To ignore this error add rvm_silence_path_mismatch_check_flag=1 to your ~/.rvmrc file."
}
__rvm_path_match_gem_home_check_warning () 
{ 
    __rvm_path_match_gem_home_check_warn "'$GEM_HOME/bin' $1" "${GEM_HOME##*/}"
}
__rvm_path_match_gem_home_check_warning_missing () 
{ 
    __rvm_path_match_gem_home_check_warn "\$GEM_HOME is not set" "$1"
}
__rvm_print_headline () 
{ 
    rvm_log "Ruby enVironment Manager ${rvm_version} $(__rvm_version_copyright)
"
}
__rvm_project_dir_check () 
{ 
    \typeset _found_file path_to_check variable variable_default;
    \typeset -a _valid_files;
    path_to_check="$1";
    variable="${2:-}";
    variable_default="${3:-}";
    _valid_files=("$path_to_check" "$path_to_check/.rvmrc" "$path_to_check/.versions.conf" "$path_to_check/.ruby-version" "$path_to_check/.rbfu-version" "$path_to_check/.rbenv-version" "$path_to_check/Gemfile");
    __rvm_find_first_file _found_file "${_valid_files[@]}" || true;
    if [[ "${_found_file##*/}" == "Gemfile" ]]; then
        if [[ -s "$_found_file" ]] && { 
            __rvm_grep "^#ruby=" "$_found_file" > /dev/null || __rvm_grep -E "^\s*ruby" "$_found_file" > /dev/null
        }; then
            true;
        else
            _found_file="";
        fi;
    else
        if [[ "${_found_file}" == "$HOME/.rvmrc" ]]; then
            _found_file="";
        fi;
    fi;
    if [[ -n "$variable" ]]; then
        eval "$variable=\"\${_found_file:-$variable_default}\"";
    fi;
    if [[ -n "${_found_file:-$variable_default}" ]]; then
        RVM_PROJECT_PATH="${_found_file:-$variable_default}";
        RVM_PROJECT_PATH="${RVM_PROJECT_PATH%/*}";
    else
        \typeset __result=$?;
        unset RVM_PROJECT_PATH;
        return $__result;
    fi
}
__rvm_project_rvmrc () 
{ 
    export __rvm_project_rvmrc_lock;
    : __rvm_project_rvmrc_lock:${__rvm_project_rvmrc_lock:=0};
    : __rvm_project_rvmrc_lock:$((__rvm_project_rvmrc_lock+=1));
    if (( __rvm_project_rvmrc_lock > 1 )); then
        return 0;
    fi;
    \typeset working_dir found_file rvm_trustworthiness_result save_PATH;
    working_dir="${1:-"$PWD"}";
    save_PATH="${PATH}";
    while :; do
        if [[ -z "$working_dir" || "$HOME" == "$working_dir" || "${rvm_prefix:-}" == "$working_dir" || "$working_dir" == "." ]]; then
            if (( ${rvm_project_rvmrc_default:-0} >= 1 )); then
                rvm_previous_environment=default;
            fi;
            if [[ -n "${rvm_previous_environment:-""}" ]] && (( ${rvm_project_rvmrc_default:-0} < 2 )); then
                __rvm_load_environment "$rvm_previous_environment";
            fi;
            __rvm_file_env_check_unload;
            unset rvm_current_rvmrc rvm_previous_environment;
            break;
        else
            if __rvm_project_dir_check "$working_dir" found_file; then
                rvm_trustworthiness_result=0;
                if [[ "${found_file}" != "${rvm_current_rvmrc:-""}" ]]; then
                    __rvm_conditionally_do_with_env __rvm_load_project_config "${found_file}" || { 
                        rvm_trustworthiness_result=$?;
                        PATH="${save_PATH}";
                        unset RVM_PROJECT_PATH
                    };
                fi;
                unset __rvm_project_rvmrc_lock;
                return "$rvm_trustworthiness_result";
            else
                working_dir="${working_dir%/*}";
            fi;
        fi;
    done;
    unset __rvm_project_rvmrc_lock;
    return 1
}
__rvm_read_lines () 
{ 
    \typeset IFS;
    IFS="
";
    if [[ "${2:--}" == "-" ]]; then
        eval "$1=( \$( \command \cat - ) )";
    else
        eval "$1=( \$( \command \cat \"\${2:--}\" ) )";
    fi
}
__rvm_readlink () 
{ 
    \readlink "$@" || return $?
}
__rvm_readlink_deep () 
{ 
    eval "
    while [[ -n \"\${$1}\" && -L \"\${$1}\" ]]
    do $1=\"\$(__rvm_readlink \"\${$1}\")\"
    done
  "
}
__rvm_record_install () 
{ 
    [[ -n "$1" ]] || return;
    \typeset recorded_ruby_name rvm_install_record_file;
    recorded_ruby_name="$( "$rvm_scripts_path/tools" strings "$1" )";
    rvm_install_record_file="$rvm_user_path/installs";
    [[ -f "$rvm_install_record_file" ]] || \command \touch "$rvm_install_record_file";
    __rvm_sed_i "$rvm_install_record_file" -e "/^$recorded_ruby_name/d";
    printf "%b" "$recorded_ruby_name -- ${rvm_configure_flags[*]}\n" >> "$rvm_install_record_file"
}
__rvm_record_ruby_configs () 
{ 
    \typeset __dir;
    for __dir in "$rvm_path/rubies/"*;
    do
        if [[ ! -L "${__dir}" && ! -s "${__dir}/config" && -x "${__dir}/bin/ruby" ]]; then
            __rvm_ruby_config_save "${__dir}/bin/ruby" "${__dir}/config" || { 
                \typeset string="${__dir##*/}";
                rvm_error "    Can not save config data for ruby: '${string}', most likely it is broken installation and you can:
    - try fix it: 'rvm reinstall ${string}', OR:
    - remove  it: 'rvm uninstall ${string} --gems'"
            };
        fi;
    done
}
__rvm_recorded_install_command () 
{ 
    \typeset recorded_ruby_name;
    recorded_ruby_name="$( "$rvm_scripts_path/tools" strings "$1" )";
    recorded_ruby_name=${recorded_ruby_name%%${rvm_gemset_seperator:-"@"}*};
    [[ -n "$recorded_ruby_name" ]] || return 1;
    if [[ -s "$rvm_user_path/installs" ]] && __rvm_grep "^$recorded_ruby_name " "$rvm_user_path/installs" > /dev/null 2>&1; then
        __rvm_grep "^$recorded_ruby_name " "$rvm_user_path/installs" | \command \head -n 1;
    else
        return 1;
    fi
}
__rvm_remote_extension () 
{ 
    case "$1" in 
        *.tar.*)
            rvm_remote_extension="tar${1##*tar}"
        ;;
        jruby-*)
            rvm_remote_extension="tar.gz"
        ;;
        *)
            rvm_remote_extension="tar.bz2"
        ;;
    esac;
    [[ "$2" != "-" ]] || printf "%b" "${rvm_remote_extension}"
}
__rvm_remote_server_path () 
{ 
    \typeset _iterator;
    _iterator="";
    while ! __rvm_remote_server_path_single 0 1 "${_iterator}" "${1:-}"; do
        : $(( _iterator+=1 ));
    done
}
__rvm_remote_server_path_single () 
{ 
    \typeset __remote_file;
    __rvm_calculate_remote_file "$@" || return $?;
    if [[ -z "${__remote_file:-}" ]]; then
        rvm_debug "No remote file name found";
        return $1;
    else
        if file_exists_at_url "${__remote_file}"; then
            rvm_debug "Remote file exists ${__remote_file}";
            printf "%b" "$( __rvm_db "rvm_remote_server_verify_downloads${3:-}" ):${__remote_file}";
        else
            if [[ -f "${rvm_archives_path}/${rvm_ruby_package_file##*/}" && "${rvm_ruby_package_file##*/}" == *bin-* ]]; then
                rvm_debug "Cached file exists ${__remote_file}";
                printf "%b" "$( __rvm_db "rvm_remote_server_verify_downloads${3:-}" ):${rvm_archives_path}/${rvm_ruby_package_file##*/}";
            else
                rvm_debug "Remote file does not exist ${__remote_file}";
                return $2;
            fi;
        fi;
    fi
}
__rvm_remove_broken_symlinks () 
{ 
    if [[ ! -e "$1" && -L "$1" ]]; then
        __rvm_rm_rf "$1";
    fi
}
__rvm_remove_from_array () 
{ 
    \typeset _array_name _iterator _search;
    \typeset -a _temp_array;
    _array_name="$1";
    _search="$2";
    shift 2;
    _temp_array=();
    for _iterator in "$@";
    do
        __rvm_string_match "$_iterator" "$_search" || _temp_array+=("$_iterator");
    done;
    eval "$_array_name=( \"\${_temp_array[@]}\" )"
}
__rvm_remove_from_path () 
{ 
    export PATH;
    \typeset _value;
    _value="${1//+(\/)//}";
    if [[ "$PATH" == *"//"* || "$PATH" == *"/:"* ]]; then
        if [[ "${_system_type}" = "Darwin" ]]; then
            PATH="$(\sed -E -e 's#/+#/#g' -e 's#/:#:#' <<<$PATH)";
        else
            PATH="$(\sed -r -e 's#/+#/#g' -e 's#/:#:#' <<<$PATH)";
        fi;
    fi;
    if __rvm_string_match ":$PATH:" "*:${_value}:*"; then
        \typeset -a _path;
        _path=();
        __rvm_custom_separated_array _path : "${PATH}";
        __rvm_remove_from_array _path "${_value}" "${_path[@]}";
        __rvm_join_array PATH : _path;
    fi
}
__rvm_remove_install_record () 
{ 
    \typeset recorded_ruby_name rvm_install_record_file;
    recorded_ruby_name="$( "$rvm_scripts_path/tools" strings "$1" )";
    rvm_install_record_file="$rvm_user_path/installs";
    if [[ -s "$rvm_install_record_file" ]]; then
        __rvm_sed_i "$rvm_install_record_file" -e "/^$recorded_ruby_name/d";
    fi
}
__rvm_remove_rvm_from_path () 
{ 
    \typeset local_rvm_path;
    __rvm_remove_from_path "${rvm_path%/}/*";
    __rvm_remove_from_path "${rvm_bin_path}";
    while local_rvm_path="$( __rvm_which rvm 2>/dev/null )"; do
        __rvm_remove_from_path "${local_rvm_path%/*}";
    done;
    builtin hash -r
}
__rvm_remove_without_gems () 
{ 
    [[ -n "${rvm_without_gems}" ]] || return 0;
    \typeset -a __gems_to_remove __extra_flags;
    __rvm_read_lines __gems_to_remove <(
    GEM_PATH="$GEM_HOME" __rvm_list_gems "" "${rvm_without_gems}"
  );
    (( ${#__gems_to_remove[@]} )) || return 0;
    __extra_flags=();
    if __rvm_version_compare "$(\command \gem --version)" -ge 2.1.0; then
        __extra_flags+=(--abort-on-dependent);
    fi;
    \typeset __gem __name __version;
    for __gem in "${__gems_to_remove[@]}";
    do
        __name="${__gem% *}";
        __version="${__gem##* }";
        __rvm_log_command "gem.uninstall.${__name}-${__version}" "$rvm_ruby_string - #uninstalling gem ${__name}-${__version}" \command \gem uninstall "${__name}" -v "${__version}" -x "${__extra_flags[@]}" || true;
    done
}
__rvm_reset_rvmrc_trust () 
{ 
    if [[ "$1" == all ]]; then
        echo "" > "${rvm_user_path:-${rvm_path}/user}/rvmrcs";
    else
        __rvm_db_ "${rvm_user_path:-${rvm_path}/user}/rvmrcs" "$(__rvm_rvmrc_key "$1")" "delete" > /dev/null 2>&1;
    fi
}
__rvm_rm_rf () 
{ 
    __rvm_rm_rf_verbose "$@"
}
__rvm_rm_rf_verbose () 
{ 
    \typeset target;
    target="${1%%+(/|.)}";
    if [[ -n "${ZSH_VERSION:-}" ]]; then
        \builtin setopt extendedglob;
    else
        if [[ -n "${BASH_VERSION:-}" ]]; then
            \builtin shopt -s extglob;
        else
            rvm_error "What the heck kind of shell are you running here???";
        fi;
    fi;
    case "${target}" in 
        *(/|.)@(|/Applications|/Developer|/Guides|/Information|/Library|/Network|/System|/User|/Users|/Volumes|/backups|/bdsm|/bin|/boot|/cores|/data|/dev|/etc|/home|/lib|/lib64|/mach_kernel|/media|/misc|/mnt|/net|/opt|/private|/proc|/root|/sbin|/selinux|/srv|/sys|/tmp|/usr|/var))
            rvm_debug "__rvm_rm_rf target is not valid - can not remove";
            return 1
        ;;
        *)
            if [[ -z "${target}" ]]; then
                rvm_debug "__rvm_rm_rf target not given";
                return 1;
            else
                if [[ -d "${target}" ]]; then
                    \command \rm -rf "${target}" || { 
                        \typeset ret=$?;
                        rvm_debug "__rvm_rm_rf error removing target dir '${target}'.";
                        return $ret
                    };
                else
                    if [[ -f "${target}" || -L "${target}" ]]; then
                        \command \rm -f "${target}" || { 
                            \typeset ret=$?;
                            rvm_debug "__rvm_rm_rf error removing target file/link '${target}'.";
                            return $ret
                        };
                    else
                        rvm_debug "__rvm_rm_rf already gone: $*";
                    fi;
                fi;
            fi
        ;;
    esac;
    true
}
__rvm_ruby_config_get () 
{ 
    \typeset variable_name ruby_path;
    variable_name="$1";
    ruby_path="${2:-$rvm_ruby_home/bin/ruby}";
    __rvm_string_match "$ruby_path" "*mruby*" && return;
    case "${variable_name:---all}" in 
        --all)
            "$ruby_path" -rrbconfig -e 'puts RbConfig::CONFIG.sort.map{|k,v| "#{k}: #{v}" }' 2> /dev/null || return $?
        ;;
        *)
            "$ruby_path" -rrbconfig -e 'puts RbConfig::CONFIG["'"$variable_name"'"]' 2> /dev/null || return $?
        ;;
    esac
}
__rvm_ruby_config_save () 
{ 
    \typeset ruby_path;
    ruby_path="${1:-$rvm_ruby_home/bin/ruby}";
    case "$ruby_path" in 
        */mruby*)
            __rvm_ruby_config_save_mruby "${2:-${ruby_path%%/bin/ruby}/config}"
        ;;
        *)
            __rvm_ruby_config_save_generic "$2"
        ;;
    esac
}
__rvm_ruby_config_save_generic () 
{ 
    \typeset config_path default_config_path;
    default_config_path="#{RbConfig::CONFIG[\"prefix\"]}/config";
    config_path="${1:-$default_config_path}";
    "$ruby_path" -rrbconfig -e '\
    File.open("'"$config_path"'","w") { |file|
      RbConfig::CONFIG.sort.each{|key,value|
        file.write("#{key.gsub(/\.|-/,"_")}=\"#{value.gsub("$","\\$")}\"\n")
      }
    }
  ' > /dev/null 2>&1
}
__rvm_ruby_config_save_mruby () 
{ 
    echo "target_cpu=\"$_system_arch\"" > "$1"
}
__rvm_ruby_package_file () 
{ 
    case "$1" in 
        *.tar.*)
            rvm_ruby_package_file="/$1"
        ;;
        rbx* | rubinius*)
            rvm_ruby_package_file="/${1//rbx/rubinius}.$(__rvm_remote_extension "$1" -)"
        ;;
        jruby-head)
            rvm_ruby_package_file="/jruby-head.$(__rvm_remote_extension "$1" -)"
        ;;
        jruby*)
            \typeset __version;
            __version="$(
        rvm_ruby_string="$1"
        rvm_remote_flag=0 __rvm_ruby_string
        echo "$rvm_ruby_version"
      )";
            rvm_ruby_package_file="/${__version}/jruby-bin-${__version}.$(__rvm_remote_extension "$1" -)"
        ;;
        "")
            rvm_ruby_package_file=""
        ;;
        ruby* | mruby*)
            rvm_ruby_package_file="/$1.$(__rvm_remote_extension "$1" -)"
        ;;
        *)
            rvm_ruby_package_file="/ruby-$1.$(__rvm_remote_extension "$1" -)"
        ;;
    esac
}
__rvm_ruby_string () 
{ 
    true ${rvm_head_flag:=0} ${rvm_delete_flag:=0};
    rvm_expanding_aliases='';
    true "${rvm_ruby_version:=}" "${rvm_gemset_name:=}" "${rvm_ruby_interpreter:=}" "${rvm_ruby_version:=}" "${rvm_ruby_tag:=}" "${rvm_ruby_patch_level:=}" "${rvm_ruby_revision:=}" ${rvm_gemset_separator:="@"} "${rvm_ruby_string:=}" ${rvm_expanding_aliases:=0} ${rvm_head_flag:=0};
    if [[ "$rvm_ruby_string" == *"${rvm_gemset_separator}"* ]]; then
        rvm_gemset_name="${rvm_ruby_string/*${rvm_gemset_separator}/}";
        rvm_ruby_string="${rvm_ruby_string/${rvm_gemset_separator}*/}";
    fi;
    if (( rvm_expanding_aliases == 0 )) && [[ -n "${rvm_ruby_string}" && "$rvm_ruby_string" != "system" ]]; then
        if [[ -f "$rvm_path/config/known_aliases" && -s "$rvm_path/config/known_aliases" ]] && expanded_alias_name="$(__rvm_db_ "$rvm_path/config/known_aliases" "$rvm_ruby_string")" && [[ -n "$expanded_alias_name" ]]; then
            rvm_ruby_string="$expanded_alias_name";
        fi;
    fi;
    if (( rvm_expanding_aliases == 0 )) && [[ -n "${rvm_ruby_string}" && "$rvm_ruby_string" != "system" ]]; then
        if [[ -f "$rvm_path/config/alias" && -s "$rvm_path/config/alias" ]] && expanded_alias_name="$(__rvm_db_ "$rvm_path/config/alias" "$rvm_ruby_string")" && [[ -n "$expanded_alias_name" ]]; then
            rvm_ruby_string="$expanded_alias_name";
        else
            if [[ "$rvm_ruby_string" == default ]]; then
                rvm_ruby_string="system";
            fi;
        fi;
        if [[ "$rvm_ruby_string" == *"${rvm_gemset_separator}"* ]]; then
            rvm_gemset_name="${rvm_ruby_string/*${rvm_gemset_separator}/}";
            rvm_ruby_string="${rvm_ruby_string/${rvm_gemset_separator}*/}";
        fi;
    fi;
    if [[ -n "$gemset_name" ]]; then
        rvm_gemset_name="$gemset_name";
        rvm_sticky_flag=1;
    fi;
    __rvm_ruby_string_parse || return $?;
    __rvm_ruby_string_find;
    detected_rvm_ruby_name="${rvm_ruby_name:-}";
    rvm_ruby_name="";
    true
}
__rvm_ruby_string_autodetect () 
{ 
    if [[ -z "${rvm_ruby_version:-}" && "${rvm_ruby_interpreter}" != "ext" && "${rvm_ruby_interpreter}" != "system" ]] && (( ${rvm_head_flag:=0} == 0 )); then
        if (( ${rvm_fuzzy_flag:-0} == 1 )); then
            rvm_ruby_version="$(
        __rvm_list_strings |
        __rvm_grep "^${rvm_ruby_interpreter}-.*${rvm_ruby_name:-}" |
        __rvm_awk -F- '{print $2}' |
        __rvm_version_sort |
        __rvm_tail -n 1
      )";
        fi;
        rvm_ruby_version="${rvm_ruby_version:-"$(
      __rvm_db "${rvm_ruby_interpreter}_version"
    )"}";
    fi;
    if (( ${rvm_head_flag:=0} )) && [[ "${rvm_ruby_interpreter}" == "ruby" ]] && __rvm_version_compare "${rvm_ruby_version}" -ge 2.1; then
        __rvm_take_n rvm_ruby_version 2 .;
    fi;
    rvm_ruby_string="${rvm_ruby_interpreter}${rvm_ruby_version:+-}${rvm_ruby_version:-}";
    if [[ "${rvm_ruby_interpreter}" == "ext" ]]; then
        true;
    else
        if [[ "${rvm_head_flag:=0}" == "1" || -n "${rvm_ruby_sha:-}" || -n "${rvm_ruby_tag:-}" ]]; then
            if [[ "${rvm_head_flag:=0}" == "1" ]]; then
                rvm_ruby_string="${rvm_ruby_string}-head";
            fi;
            if [[ -n "${rvm_ruby_sha:-}" ]]; then
                rvm_ruby_string="${rvm_ruby_string}-s${rvm_ruby_sha}";
            else
                if [[ -n "${rvm_ruby_tag:-}" ]]; then
                    rvm_ruby_string="${rvm_ruby_string}-${rvm_ruby_tag}";
                fi;
            fi;
            if [[ ! -d "${rvm_rubies_path}/${rvm_ruby_string}" ]] && (( ${rvm_fuzzy_flag:-0} == 1 )); then
                \typeset new_ruby_string;
                new_ruby_string="$(
        __rvm_list_strings |
        __rvm_grep "^${rvm_ruby_string}.*${rvm_ruby_name:-}" |
        __rvm_version_sort |
        __rvm_tail -n 1
      )";
                rvm_ruby_string="${new_ruby_string:-$rvm_ruby_string}";
            fi;
        else
            if [[ -n "${rvm_ruby_revision:-}" ]]; then
                rvm_ruby_string="${rvm_ruby_string}-${rvm_ruby_revision}";
            else
                if [[ -n "${rvm_ruby_patch_level:-}" ]]; then
                    rvm_ruby_string="${rvm_ruby_string}-${rvm_ruby_patch_level}";
                else
                    if [[ -n "${rvm_ruby_user_tag:-}" ]]; then
                        rvm_ruby_string="${rvm_ruby_string}-${rvm_ruby_user_tag}";
                    else
                        if (( ${rvm_fuzzy_flag:-0} == 1 )) && [[ "${rvm_ruby_interpreter}" == "ruby" || "${rvm_ruby_interpreter}" == "ree" ]]; then
                            rvm_ruby_patch_level="$(
        __rvm_list_strings |
        __rvm_grep "^${rvm_ruby_interpreter}-${rvm_ruby_version}-.*${rvm_ruby_name:-}" |
        __rvm_awk -F- '{print $3}' |
        __rvm_version_sort |
        __rvm_tail -n 1
      )";
                        fi;
                        [[ -n "${rvm_ruby_patch_level:-""}" ]] || __rvm_db_system "${rvm_ruby_interpreter}_${rvm_ruby_version}_patch_level" rvm_ruby_patch_level;
                        if [[ -n "${rvm_ruby_patch_level:-""}" ]]; then
                            rvm_ruby_string="${rvm_ruby_string}-${rvm_ruby_patch_level}";
                        fi;
                    fi;
                fi;
            fi;
        fi;
    fi;
    true
}
__rvm_ruby_string_find () 
{ 
    if __rvm_ruby_string_installed; then
        true;
    else
        if __rvm_ruby_string_remotely_available; then
            true;
        else
            __rvm_ruby_string_autodetect;
            case "${rvm_ruby_string}" in 
                ruby-+([1-9]) | ruby-+([1-9]).+([0-9]) | ruby-1.+([1-9]).+([0-9]) | jruby-[19]*)
                    __rvm_ruby_string_latest && __rvm_ruby_string_parse_ || return $?
                ;;
            esac;
        fi;
    fi;
    if [[ -n "${rvm_ruby_name:-}" && ! "${rvm_ruby_string}" == *"-${rvm_ruby_name}" ]]; then
        rvm_ruby_string="${rvm_ruby_string}${rvm_ruby_name:+-}${rvm_ruby_name:-}";
    fi
}
__rvm_ruby_string_fuzzy () 
{ 
    \typeset new_ruby_string __search;
    __search="${rvm_ruby_string}";
    if [[ -n "${rvm_ruby_name:-}" ]]; then
        __search="${__search%${rvm_ruby_name:-}}.*${rvm_ruby_name:-}";
    fi;
    new_ruby_string="$(
    __rvm_list_strings |
    __rvm_grep "${__search//\./\\.}" |
    __rvm_version_sort |
    __rvm_tail -n 1
  )";
    if [[ -n "${new_ruby_string}" ]]; then
        rvm_ruby_string="${new_ruby_string}";
    else
        return $?;
    fi
}
__rvm_ruby_string_fuzzy_remote () 
{ 
    \typeset new_ruby_string __search;
    __search="${rvm_ruby_string}";
    if [[ -n "${rvm_ruby_name:-}" ]]; then
        __search="${__search%${rvm_ruby_name:-}}.*${rvm_ruby_name:-}";
    fi;
    new_ruby_string="$(
    __list_remote_all |
    __rvm_awk -F/ '{ x=$NF;
      gsub(".tar.*","",x);
      gsub("jruby-bin","jruby",x);
      gsub("rubinius","rbx",x);
      print x}' |
    __rvm_version_sort |
    __rvm_awk '
BEGIN{found=""; any=""}
/^'"${__search}"'$/ {found=$1}
/^'"${__search}"'/ {any=$1}
END{if (found) print found; else if (any) print any;}
'
  )";
    rvm_ruby_string="${new_ruby_string:-$rvm_ruby_string}"
}
__rvm_ruby_string_installed () 
{ 
    \typeset __ruby_inst_dir="$rvm_rubies_path/${rvm_ruby_string}";
    if [[ -n "${rvm_ruby_name:-}" && ! "${rvm_ruby_string}" == *"-${rvm_ruby_name}" ]]; then
        __ruby_inst_dir="${__ruby_inst_dir}-${rvm_ruby_name}";
    fi;
    [[ -n "$rvm_ruby_interpreter" && -n "${rvm_ruby_string}" && -d "${__ruby_inst_dir}" ]] && [[ -z "${rvm_gemset_name}" || ${rvm_create_flag:-0} -eq 1 || -d "${__ruby_inst_dir}${rvm_gemset_separator}${rvm_gemset_name}" ]]
}
__rvm_ruby_string_latest () 
{ 
    \typeset check_ruby_string new_ruby_string;
    check_ruby_string="";
    if [[ -n "${rvm_ruby_interpreter}" ]]; then
        check_ruby_string+="${rvm_ruby_interpreter}-";
    fi;
    if [[ -n "${rvm_ruby_version}" ]]; then
        check_ruby_string+="${rvm_ruby_version//\./\.}.*";
    fi;
    if [[ -n "${rvm_ruby_patch_level}" ]]; then
        check_ruby_string+="${rvm_ruby_patch_level//\./\.}.*";
    fi;
    if [[ -z "${check_ruby_string}" ]]; then
        check_ruby_string="$rvm_ruby_string";
    fi;
    new_ruby_string="$(
    \command \cat "$rvm_path/config/known_strings" |
    __rvm_grep "${check_ruby_string}" |
    __rvm_version_sort |
    __rvm_tail -n 1
  )";
    if [[ -n "${new_ruby_string}" ]]; then
        rvm_ruby_string="${new_ruby_string}";
    else
        rvm_error "Unknown ruby string (do not know how to handle): $rvm_ruby_string.";
        return 1;
    fi
}
__rvm_ruby_string_parse () 
{ 
    __rvm_ruby_string_parse_ || true;
    if (( ${rvm_fuzzy_flag:-0} == 1 )) && [[ ! -d "${rvm_rubies_path}/${rvm_ruby_string}" ]]; then
        if (( ${rvm_remote_flag:-0} == 1 )); then
            __rvm_ruby_string_fuzzy || __rvm_ruby_string_fuzzy_remote || return $?;
        else
            __rvm_ruby_string_fuzzy || true;
        fi;
    fi;
    __rvm_ruby_string_parse_ || return $?;
    if [[ -z "${rvm_ruby_interpreter}" ]]; then
        rvm_error "Unknown ruby interpreter version (do not know how to handle): $rvm_ruby_string.";
        return 1;
    fi
}
__rvm_ruby_string_parse_ () 
{ 
    \typeset ruby_string gemset_name expanded_alias_name repo_url branch_name ruby_name;
    ruby_string="${rvm_ruby_string:-}";
    gemset_name="${rvm_gemset_name:-}";
    repo_url="${rvm_ruby_repo_url:-}";
    branch_name="${rvm_ruby_repo_branch:-}";
    ruby_name="${rvm_ruby_name:-}";
    __rvm_unset_ruby_variables;
    rvm_ruby_repo_url="${repo_url:-}";
    rvm_ruby_repo_branch="${branch_name:-}";
    rvm_ruby_name="$ruby_name";
    export rvm_head_flag=0;
    if [[ -z "${ruby_string}" || "${ruby_string}" == "current" ]]; then
        if [[ "${GEM_HOME:-}" == *"${rvm_gems_path}"* ]]; then
            ruby_string="${GEM_HOME##*\/}";
            ruby_string="${ruby_string/%${rvm_gemset_separator:-"@"}*}";
        else
            ruby_string="system";
        fi;
    fi;
    strings=();
    __rvm_custom_separated_array strings - "${ruby_string}";
    rvm_ruby_string="${ruby_string}";
    if [[ -n "${ZSH_VERSION:-}" ]]; then
        setopt LOCAL_OPTIONS KSH_GLOB;
    fi;
    for string in ${strings[@]};
    do
        case "$string" in 
            head)
                rvm_ruby_patch_level="";
                rvm_ruby_revision="";
                rvm_ruby_tag="";
                rvm_head_flag=1
            ;;
            system)
                rvm_ruby_interpreter="system";
                rvm_ruby_patch_level="";
                rvm_ruby_tag="";
                rvm_ruby_revision="";
                rvm_ruby_version="";
                rvm_gemset_name="";
                rvm_head_flag=0;
                return 0
            ;;
            ext | external)
                rvm_ruby_interpreter="ext";
                rvm_ruby_patch_level="";
                rvm_ruby_tag="";
                rvm_ruby_revision="";
                rvm_ruby_version="";
                rvm_head_flag=0;
                rvm_ruby_name="${ruby_string:-${rvm_ruby_string}}";
                rvm_ruby_name="${rvm_ruby_name#*-}";
                break
            ;;
            nightly | weekly | monthly)
                case "${rvm_ruby_interpreter}" in 
                    rbx | rubinius)
                        rvm_ruby_patch_level="$string"
                    ;;
                    *)
                        rvm_ruby_version="$string"
                    ;;
                esac;
                rvm_nightly_flag=1
            ;;
            nightly* | weekly* | monthly*)
                case "${rvm_ruby_interpreter}" in 
                    rbx | rubinius)
                        rvm_ruby_patch_level="$string"
                    ;;
                    *)
                        rvm_ruby_version="$string"
                    ;;
                esac
            ;;
            preview*)
                rvm_ruby_patch_level="$string"
            ;;
            rc[0-9]*)
                rvm_ruby_patch_level="$string"
            ;;
            +([0-9]).+([0-9]).[0-9]*)
                rvm_ruby_version="${string}";
                rvm_ruby_revision="";
                rvm_ruby_tag=""
            ;;
            [0-9][0-9]*)
                case "${rvm_ruby_interpreter:-""}" in 
                    ree)
                        rvm_ruby_patch_level="$string";
                        rvm_ruby_revision=""
                    ;;
                    maglev)
                        rvm_ruby_version="$string";
                        rvm_ruby_revision="";
                        rvm_ruby_patch_level=""
                    ;;
                    *)
                        rvm_ruby_version="${string}";
                        rvm_ruby_revision="";
                        rvm_ruby_tag=""
                    ;;
                esac
            ;;
            [0-9]*)
                rvm_ruby_version="${string}";
                rvm_ruby_revision="";
                rvm_ruby_tag=""
            ;;
            p[0-9]*)
                rvm_ruby_patch_level="$string"
            ;;
            r[0-9]*)
                rvm_ruby_patch_level="";
                rvm_ruby_revision="$string"
            ;;
            s[0-9a-zA-ZuU]*)
                rvm_ruby_revision="";
                rvm_ruby_sha="${string#s}"
            ;;
            tv[0-9]* | t[0-9]*)
                rvm_ruby_patch_level="";
                rvm_ruby_revision="";
                rvm_ruby_tag="$string"
            ;;
            m[0-9]*)
                rvm_ruby_mode="$string"
            ;;
            u[0-9a-zA-ZuU]*)
                rvm_ruby_patch_level="";
                rvm_ruby_revision="";
                rvm_ruby_tag="";
                rvm_ruby_patch="";
                rvm_ruby_user_tag="$string"
            ;;
            b[0-9]*)
                rvm_ruby_repo_branch="${string}";
                rvm_head_flag=1
            ;;
            rubinius)
                rvm_ruby_interpreter="rbx"
            ;;
            opal | ruby | rbx | jruby | macruby | ree | maglev | ironruby | mruby | topaz)
                rvm_ruby_interpreter="$string"
            ;;
            [a-zA-ZuU]*([0-9a-zA-ZuU]|_))
                rvm_ruby_name="$string"
            ;;
            *)
                rvm_ruby_string="${ruby_string:-}";
                return 0
            ;;
        esac;
    done;
    if [[ -z "${rvm_ruby_interpreter}" && -n "${rvm_ruby_version}" ]]; then
        case "${rvm_ruby_version}" in 
            1.[5-7]* | 9*)
                rvm_ruby_interpreter=jruby
            ;;
            1.[8-9]* | 2*)
                rvm_ruby_interpreter=ruby
            ;;
        esac;
        if [[ -n "${rvm_ruby_interpreter}" ]]; then
            rvm_ruby_string="${rvm_ruby_interpreter}-${rvm_ruby_string}";
        fi;
    fi;
    true
}
__rvm_ruby_string_paths_under () 
{ 
    \typeset __search_path part parts IFS;
    IFS=" ";
    __search_path="${1%/}";
    if [[ -n "${ZSH_VERSION:-}" ]]; then
        parts=(${=rvm_ruby_string//-/ });
    else
        parts=(${rvm_ruby_string//-/ });
    fi;
    echo "$__search_path";
    for part in "${parts[@]}";
    do
        __search_path="$__search_path/$part";
        echo "$__search_path";
    done
}
__rvm_ruby_string_remotely_available () 
{ 
    (( ${rvm_remote_flag:-0} == 1 )) && [[ -n "$rvm_ruby_interpreter" && -n "${rvm_ruby_string}" ]] && __rvm_remote_server_path "${rvm_ruby_string}" > /dev/null
}
__rvm_ruby_strings_exist () 
{ 
    for rvm_ruby_string in ${@//,/ };
    do
        rvm_gemset_name="";
        rvm_verbose_flag=0 __rvm_use "${rvm_ruby_string}" > /dev/null 2>&1 || return $?;
        true rvm_gemset_name:${rvm_gemset_name:=${rvm_expected_gemset_name}};
        printf "%b" "${rvm_ruby_string}${rvm_gemset_name:+@}${rvm_gemset_name:-}\n";
    done;
    unset rvm_ruby_string
}
__rvm_rubygems_create_link () 
{ 
    \typeset ruby_lib_gem_path;
    \command \mkdir -p "$rvm_ruby_gem_home/bin";
    rubygems_detect_ruby_lib_gem_path "${1:-ruby}" || return 0;
    if [[ -L "$ruby_lib_gem_path" && -w "$ruby_lib_gem_path" ]]; then
        rm -rf "$ruby_lib_gem_path";
    fi;
    if [[ -e "$rvm_ruby_global_gems_path" && ! -L "$rvm_ruby_global_gems_path" ]]; then
        rm -rf "$rvm_ruby_global_gems_path";
    fi;
    [[ -d "$ruby_lib_gem_path" ]] || \command \mkdir -p "$ruby_lib_gem_path";
    if [[ -w "$ruby_lib_gem_path" ]]; then
        [[ -L "$rvm_ruby_global_gems_path" ]] || ln -fs "$ruby_lib_gem_path" "$rvm_ruby_global_gems_path";
    else
        [[ -d "$rvm_ruby_global_gems_path" ]] || \command \mkdir -p "$rvm_ruby_global_gems_path";
    fi;
    \command \mkdir -p "$rvm_ruby_global_gems_path/bin"
}
__rvm_run_wrapper () 
{ 
    ( file="$1";
    action="${2:-}";
    shift 2;
    rubies_string="${1:-}";
    args=($@);
    source "$rvm_scripts_path"/base;
    source "$rvm_scripts_path"/$file )
}
__rvm_rvmrc_key () 
{ 
    printf "%b" "$1" | \command \tr '[#/.=()]' _;
    return $?
}
__rvm_rvmrc_match_all () 
{ 
    [[ "${1:-}" == "all" || "${1:-}" == "all.rvmrcs" || "${1:-}" == "allGemfiles" ]]
}
__rvm_rvmrc_notice_display_post () 
{ 
    __rvm_table "Viewing of ${_rvmrc} complete."  <<-TEXT
Trusting an ${_rvmrc_base} file means that whenever you cd into this directory, RVM will run this ${_rvmrc_base} shell script.
Note that if the contents of the file change, you will be re-prompted to review the file and adjust its trust settings. You may also change the trust settings manually at any time with the 'rvm rvmrc' command.
TEXT

}
__rvm_rvmrc_notice_initial () 
{ 
    __rvm_table "NOTICE"  <<-TEXT
RVM has encountered a new or modified ${_rvmrc_base} file in the current directory, this is a shell script and therefore may contain any shell commands.

Examine the contents of this file carefully to be sure the contents are safe before trusting it!
Do you wish to trust '${_rvmrc}'?
Choose v[iew] below to view the contents
TEXT

}
__rvm_rvmrc_stored_trust () 
{ 
    [[ -f "$1" ]] || return 1;
    __rvm_db_ "${rvm_user_path:-${rvm_path}/user}/rvmrcs" "$(__rvm_rvmrc_key "$1")" || return $?
}
__rvm_rvmrc_stored_trust_check () 
{ 
    \typeset _first _second _rvmrc _rvmrc_base;
    if [[ -n "${ZSH_VERSION:-}" ]]; then
        _first=1;
    else
        _first=0;
    fi;
    _second=$(( _first + 1 ));
    _rvmrc="${1}";
    _rvmrc_base="$(basename "${_rvmrc}")";
    if [[ -f "$_rvmrc" ]]; then
        saveIFS=$IFS;
        IFS=';';
        trust=($(__rvm_rvmrc_stored_trust "$_rvmrc"));
        IFS=$saveIFS;
        if [[ "${trust[${_second}]:-'#'}" != "$(__rvm_checksum_for_contents "$_rvmrc")" ]]; then
            echo "The '$_rvmrc' contains unreviewed changes.";
            return 1;
        else
            if [[ "${trust[${_first}]}" == '1' ]]; then
                echo "The '$_rvmrc' is currently trusted.";
                return 0;
            else
                if [[ "${trust[${_first}]}" == '0' ]]; then
                    echo "The '$_rvmrc' is currently untrusted.";
                    return 1;
                else
                    echo "The trustiworthiness of '$_rvmrc' is currently unknown.";
                    return 1;
                fi;
            fi;
        fi;
    else
        echo "There is no '$_rvmrc'";
        return 1;
    fi
}
__rvm_rvmrc_to () 
{ 
    case "${1:-help}" in 
        .ruby-version | ruby-version)
            __rvm_rvmrc_to_ruby_version || return $?
        ;;
        help)
            rvm_help rvmrc to;
            return 0
        ;;
        *)
            rvm_error_help "Unknown subcommand '$1'" rvmrc to;
            return 1
        ;;
    esac
}
__rvm_rvmrc_to_ruby_version () 
{ 
    ( [[ -s "$PWD/.rvmrc" ]] || { 
        rvm_error "No .rvmrc to convert";
        return 2
    };
    __rvm_load_project_config "$PWD/.rvmrc" || { 
        rvm_error "Could not load .rvmrc";
        return 3
    };
    __rvm_set_ruby_version;
    \command \rm .rvmrc || { 
        rvm_error "Could not remove .rvmrc";
        return 4
    } )
}
__rvm_rvmrc_tools () 
{ 
    \typeset rvmrc_action rvmrc_warning_action rvmrc_path saveIFS trust rvmrc_ruby;
    rvmrc_action="$1";
    (( $# )) && shift || true;
    if [[ "${rvmrc_action}" == "warning" ]]; then
        rvmrc_warning_action="${1:-}";
        (( $# )) && shift || true;
    fi;
    if [[ "${rvmrc_action}" == "create" ]]; then
        rvmrc_ruby="${1:-${GEM_HOME##*/}}";
        rvmrc_path="$(__rvm_cd "$PWD" >/dev/null 2>&1; pwd)/${2:-.rvmrc}";
    else
        if [[ "$1" == ".rvmrc" ]]; then
            rvmrc_path="$PWD/.rvmrc";
        else
            if [[ "${rvmrc_action}" == "to" || "${rvmrc_action}" == "warning" ]] || [[ -n "${1:-}" ]]; then
                rvmrc_path="$1";
            else
                rvmrc_path="$PWD/.rvmrc";
            fi;
        fi;
    fi;
    if [[ "${rvmrc_action}" == "to" || "${rvmrc_action}" == "warning" || "${rvmrc_action}" == "create" ]] || __rvm_rvmrc_match_all "${rvmrc_path:-}"; then
        true;
    else
        __rvm_project_dir_check "${rvmrc_path}" rvmrc_path "${rvmrc_path}/.rvmrc";
    fi;
    rvmrc_path="${rvmrc_path//\/\///}";
    rvmrc_path="${rvmrc_path%/}";
    case "$rvmrc_action" in 
        warning)
            __rvmrc_warning "${rvmrc_warning_action:-}" "$rvmrc_path" || return $?
        ;;
        to)
            __rvm_rvmrc_to "$rvmrc_path" || return $?
        ;;
        create)
            ( rvm_create_flag=1 __rvm_use "${rvmrc_ruby}";
            case "${rvmrc_path}" in 
                */.rvmrc | */--rvmrc)
                    __rvm_set_rvmrc
                ;;
                */.ruby-version | */--ruby-version)
                    __rvm_set_ruby_version
                ;;
                */.versions.conf | */--versions-conf)
                    __rvm_set_versions_conf
                ;;
                *)
                    rvm_error "Unrecognized project file format.";
                    return 1
                ;;
            esac )
        ;;
        reset)
            __rvm_reset_rvmrc_trust "$rvmrc_path" && rvm_log "Reset trust for $rvmrc_path" || rvm_error "Reset trust for $rvmrc_path - failed"
        ;;
        trust)
            __rvm_trust_rvmrc "$rvmrc_path" && rvm_log "Marked $rvmrc_path as trusted" || rvm_error "Marked $rvmrc_path as trusted - failed"
        ;;
        untrust)
            __rvm_untrust_rvmrc "$rvmrc_path" && rvm_log "Marked $rvmrc_path as untrusted" || rvm_error "Marked $rvmrc_path as untrusted - failed"
        ;;
        trusted)
            __rvm_rvmrc_stored_trust_check "$rvmrc_path" || return $?
        ;;
        is_trusted)
            __rvm_rvmrc_stored_trust_check "$rvmrc_path" > /dev/null
        ;;
        load)
            rvm_current_rvmrc="" rvm_trust_rvmrcs_flag=1 __rvm_project_rvmrc "${rvmrc_path%/.rvmrc}"
        ;;
        try_to_read_ruby)
            __rvm_rvmrc_tools_try_to_read_ruby "$@" || return $?
        ;;
        *)
            rvm_error "Usage: rvm rvmrc {trust,untrust,trusted,load,reset,is_trusted,try_to_read_ruby,create}";
            return 1
        ;;
    esac;
    return $?
}
__rvm_rvmrc_tools_read_ruby () 
{ 
    \typeset __result;
    \typeset -a rvmrc_tools_read_ruby;
    rvmrc_tools_read_ruby=();
    __rvm_save_variables rvmrc_tools_read_ruby rvm_current_rvmrc result current_result rvm_token next_token rvm_action _string;
    rvm_current_rvmrc="";
    rvm_action="${rvm_action:-use}" rvm_trust_rvmrcs_flag=1 __rvm_project_rvmrc "$rvmrc_path" > /dev/null && rvm_ruby_string="${GEM_HOME##*/}" && rvm_ruby_strings="$rvm_ruby_string" || __result=101;
    __rvm_set_env "" "${rvmrc_tools_read_ruby[@]}";
    return ${__result:-0}
}
__rvm_rvmrc_tools_try_to_read_ruby () 
{ 
    case "$rvmrc_path" in 
        */.rvmrc)
            if [[ -n "${rvm_trust_rvmrcs_flag:-}" ]]; then
                export rvm_trust_rvmrcs_flag;
            fi;
            rvmrc_path="$(cd "$(dirname "$rvmrc_path")"; pwd)/.rvmrc";
            __rvm_rvmrc_tools is_trusted "$(dirname "$rvmrc_path")" .rvmrc || ( rvm_promptless=1 __rvm_project_rvmrc "$rvmrc_path" > /dev/null 2>&1 );
            if __rvm_rvmrc_tools is_trusted "$(dirname "$rvmrc_path")" .rvmrc; then
                __rvm_rvmrc_tools_read_ruby "$@" || return $?;
            else
                return 1;
            fi
        ;;
        *)
            __rvm_rvmrc_tools_read_ruby "$@" || return $?
        ;;
    esac
}
__rvm_save_variables () 
{ 
    \typeset __save_to __key;
    __save_to="$1";
    shift;
    for __key in "$@";
    do
        eval "${__save_to}+=( \"\${__key}=\${${__key}}\" )";
    done
}
__rvm_sed () 
{ 
    \sed "$@" || return $?
}
__rvm_sed_i () 
{ 
    \typeset _filename _executable _user;
    [[ -n "${1:-}" ]] || { 
        rvm_debug "no file given for __rvm_sed_i";
        return 0
    };
    _filename="$1";
    shift;
    if [[ -x "${_filename}" ]]; then
        _executable=true;
    fi;
    _user="$( __rvm_statf "%u:%g" "%u:%g" "${_filename}" )";
    { 
        __rvm_sed "$@" < "${_filename}" > "${_filename}.new" && \command \mv -f "${_filename}.new" "${_filename}"
    } 2>&1 | rvm_debug_stream;
    if [[ -n "${_executable:-}" && ! -x "${_filename}" ]]; then
        chmod +x "${_filename}";
    fi;
    if [[ "$_user" != "$( __rvm_statf "%u:%g" "%u:%g" "${_filename}" )" ]]; then
        chown "$_user" "${_filename}";
    fi
}
__rvm_select () 
{ 
    true ${rvm_gemset_name:=};
    __rvm_select_set_variable_defaults && __rvm_select_detect_ruby_string "${1:-}" && __rvm_ruby_string && __rvm_select_after_parse || return $?
}
__rvm_select_after_parse () 
{ 
    __rvm_select_interpreter_variables && __rvm_select_version_variables && __rvm_select_default_variables || return $?;
    [[ "system" == "$rvm_ruby_interpreter" ]] || __rvm_gemset_select || return $result;
    rvm_ruby_selected_flag=1
}
__rvm_select_default_variables () 
{ 
    if [[ "${rvm_ruby_interpreter}" != ext ]]; then
        rvm_ruby_package_name="${rvm_ruby_package_name:-${rvm_ruby_string//-n*}}";
    fi;
    rvm_ruby_home="$rvm_rubies_path/$rvm_ruby_string";
    rvm_ruby_binary="$rvm_ruby_home/bin/ruby";
    rvm_ruby_irbrc="$rvm_ruby_home/.irbrc"
}
__rvm_select_detect_ruby_string () 
{ 
    rvm_ruby_string="${1:-${rvm_ruby_string:-${rvm_env_string:-}}}";
    if [[ -z "${rvm_ruby_string:-}" ]]; then
        rvm_ruby_string="${rvm_ruby_interpreter:-}";
        rvm_ruby_string="${rvm_ruby_string:-}${rvm_ruby_version:+-}${rvm_ruby_version:-}";
        rvm_ruby_string="${rvm_ruby_string:-}${rvm_ruby_patch_level:+-}${rvm_ruby_patch_level:-}";
        rvm_ruby_string="${rvm_ruby_string:-}${rvm_ruby_revision:+-}${rvm_ruby_revision:-}";
        if [[ -n "${rvm_ruby_name:-}" ]]; then
            rvm_ruby_name="$rvm_ruby_string-$rvm_ruby_name";
        fi;
    fi
}
__rvm_select_interpreter_common () 
{ 
    rvm_ruby_interpreter="${1}";
    rvm_ruby_version="head";
    rvm_ruby_patch_level="";
    export rvm_head_flag=1;
    rvm_ruby_repo_url="${rvm_ruby_repo_url:-$(__rvm_db "${1}_repo_url")}";
    rvm_ruby_url=$rvm_ruby_repo_url;
    rvm_ruby_configure="";
    rvm_ruby_make="";
    rvm_ruby_make_install=""
}
__rvm_select_interpreter_current () 
{ 
    ruby_binary="$(builtin command -v ruby)";
    if (( $? == 0)) && __rvm_string_match "$ruby_binary" "*rvm*"; then
        rvm_ruby_string="$(dirname "$ruby_binary" | __rvm_xargs dirname | __rvm_xargs basename)";
    else
        rvm_ruby_interpreter="system";
    fi
}
__rvm_select_interpreter_default () 
{ 
    true
}
__rvm_select_interpreter_ext () 
{ 
    if [[ -z "${rvm_ruby_name:-${detected_rvm_ruby_name:-}}" ]]; then
        rvm_error "External ruby name was not specified!";
        return 1;
    fi
}
__rvm_select_interpreter_ironruby () 
{ 
    rvm_ruby_patch_level="";
    if (( ${rvm_head_flag:=0} == 1 )); then
        rvm_ruby_version="head";
        rvm_ruby_package_name="${rvm_ruby_string}";
        rvm_ruby_repo_url="${rvm_ruby_repo_url:-$(__rvm_db "ironruby_repo_url")}";
        rvm_ruby_url="${rvm_ruby_repo_url:-$(__rvm_db "ironruby_repo_url")}";
        rvm_disable_binary_flag=1;
    else
        rvm_archive_extension="zip";
        rvm_ruby_version=${rvm_ruby_version:-"$(__rvm_db "ironruby_version")"};
        rvm_ruby_package_name="${rvm_ruby_interpreter}-${rvm_ruby_version}";
        rvm_ruby_package_file="${rvm_ruby_interpreter}-${rvm_ruby_version}.${rvm_archive_extension}";
        rvm_ruby_url="$(__rvm_db "ironruby_${rvm_ruby_version}_url")";
    fi;
    export rvm_ruby_version rvm_ruby_string rvm_ruby_package_name rvm_ruby_repo_url rvm_ruby_url rvm_archive_extension;
    true
}
__rvm_select_interpreter_jruby () 
{ 
    rvm_ruby_patch_level="";
    rvm_ruby_repo_url="${rvm_ruby_repo_url:-$(__rvm_db "jruby_repo_url")}";
    rvm_ruby_url="${rvm_ruby_repo_url:-$(__rvm_db "jruby_repo_url")}";
    if (( ${rvm_head_flag:=0} == 1 )); then
        (( ${rvm_remote_flag:-0} == 1 )) || rvm_disable_binary_flag=1;
        rvm_ruby_version="head";
    else
        if (( ${rvm_18_flag:-0} || ${rvm_19_flag:-0} || ${rvm_20_flag:-0} || ${#rvm_patch_names[@]} )); then
            rvm_disable_binary_flag=1;
        fi;
        rvm_ruby_version="${rvm_ruby_version:-"$(__rvm_db "jruby_version")"}";
        rvm_ruby_tag="${rvm_ruby_tag:-${rvm_ruby_version}}";
    fi;
    alias jruby_ng="jruby --ng";
    alias jruby_ng_server="jruby --ng-server";
    true
}
__rvm_select_interpreter_macruby () 
{ 
    if [[ "Darwin" == "${_system_type}" ]]; then
        rvm_ruby_package_name="${rvm_ruby_interpreter}-${rvm_ruby_version}";
        if (( ${rvm_head_flag:=0} == 1 )); then
            rvm_ruby_version="";
            rvm_ruby_tag="";
            rvm_ruby_revision="head";
            __rvm_db "macruby_repo_url" "rvm_ruby_repo_url";
            rvm_ruby_url="$rvm_ruby_repo_url";
            rvm_disable_binary_flag=1;
        else
            if [[ "${rvm_ruby_version:-}" == *"nightly"* ]]; then
                __rvm_select_macruby_nightly;
            else
                if [[ -n "${rvm_ruby_version:-}" ]]; then
                    __rvm_db "macruby_${rvm_ruby_version}_url" "rvm_ruby_url";
                    [[ -n "${rvm_ruby_url:-}" ]] || __rvm_db "macruby_url" "rvm_ruby_url";
                    rvm_ruby_package_name="MacRuby%20${rvm_ruby_version}.zip";
                    rvm_ruby_package_file="$rvm_ruby_package_name";
                    rvm_ruby_url="$rvm_ruby_url/$rvm_ruby_package_name";
                else
                    __rvm_db "macruby_version" "rvm_ruby_version";
                    __rvm_db "macruby_url" "rvm_ruby_url";
                    rvm_ruby_package_name="MacRuby%20${rvm_ruby_version}.zip";
                    rvm_ruby_package_file="$rvm_ruby_package_name";
                    rvm_ruby_url="$rvm_ruby_url/$rvm_ruby_package_name";
                fi;
            fi;
        fi;
        rvm_ruby_patch_level="";
    else
        rvm_error "MacRuby can only be installed on a Darwin OS.";
    fi;
    true
}
__rvm_select_interpreter_maglev () 
{ 
    rvm_ruby_patch_level="";
    maglev_url="$(__rvm_db "maglev_url")";
    system="${_system_type}";
    if [[ "$MACHTYPE" == x86_64-apple-darwin* ]]; then
        arch="i386";
    else
        arch="${_system_arch}";
    fi;
    if (( ${rvm_head_flag:=0} == 1 )) || [[ "$rvm_ruby_version" == "head" ]]; then
        rvm_head_flag=1;
        rvm_ruby_version="head";
        rvm_ruby_repo_url="${rvm_ruby_repo_url:-$(__rvm_db "maglev_repo_url")}";
        rvm_ruby_url="${rvm_ruby_repo_url:-$(__rvm_db "maglev_repo_url")}";
        rvm_gemstone_version=$(
      __rvm_curl -s https://raw.githubusercontent.com/MagLev/maglev/master/version.txt |
        __rvm_grep "^GEMSTONE" | cut -f2 -d-
    );
        rvm_gemstone_package_file="GemStone-${rvm_gemstone_version}.${system}-${arch}";
        rvm_disable_binary_flag=1;
    else
        rvm_ruby_package_file="MagLev-${rvm_ruby_version}";
        rvm_ruby_version="${rvm_ruby_version:-"$(__rvm_db "maglev_version")"}";
        rvm_ruby_package_name="${rvm_ruby_interpreter}-${rvm_ruby_version}";
        rvm_ruby_url="${rvm_ruby_url:-"$maglev_url/${rvm_ruby_package_file}.${rvm_archive_extension}"}";
        rvm_gemstone_version=$(
      __rvm_curl -s https://raw.githubusercontent.com/MagLev/maglev/MagLev-${rvm_ruby_version}/version.txt |
        __rvm_grep "^GEMSTONE" | cut -f2 -d-
    );
        rvm_gemstone_package_file="GemStone-${rvm_gemstone_version}.${system}-${arch}";
    fi;
    export MAGLEV_HOME="$rvm_ruby_home";
    export GEMSTONE_GLOBAL_DIR=$MAGLEV_HOME;
    rvm_gemstone_url="$maglev_url/${rvm_gemstone_package_file}.${rvm_archive_extension}";
    true
}
__rvm_select_interpreter_missing () 
{ 
    return 2
}
__rvm_select_interpreter_mruby () 
{ 
    rvm_ruby_interpreter="mruby";
    rvm_ruby_patch_level="";
    rvm_ruby_repo_url="${rvm_ruby_repo_url:-$(__rvm_db "mruby_repo_url")}";
    rvm_ruby_url=$rvm_ruby_repo_url;
    rvm_ruby_configure="";
    rvm_ruby_make="";
    rvm_ruby_make_install="";
    export rvm_skip_autoreconf_flag=1;
    if [[ -z "${rvm_ruby_version:-}" ]]; then
        rvm_head_flag=1;
    else
        rvm_head_flag=0;
        rvm_archive_extension="tar.gz";
        rvm_ruby_package_file="${rvm_ruby_version}";
    fi
}
__rvm_select_interpreter_opal () 
{ 
    __rvm_select_interpreter_common "opal"
}
__rvm_select_interpreter_rbx () 
{ 
    __rvm_select_rbx_nightly || return $?;
    rvm_ruby_interpreter="rbx";
    __rvm_select_rbx_compatibility_branch;
    if (( ${rvm_head_flag:=1} == 0 )) && [[ -z "${rvm_ruby_repo_branch:-}" ]] && [[ "${rvm_ruby_version}" != "head" ]]; then
        if __rvm_version_compare "${rvm_ruby_version}" -ge "2.0.0"; then
            rbx_url="$( __rvm_db "rbx_2.0.0_url" )";
            rvm_archive_extension="tar.bz2";
            rvm_ruby_package_file="rubinius-${rvm_ruby_version}";
            rvm_ruby_url="${rbx_url}/${rvm_ruby_package_file}.${rvm_archive_extension}";
        else
            rbx_url=${rbx_url:-$(__rvm_db "rbx_url")};
            rvm_archive_extension="tar.gz";
            rvm_ruby_package_file="rubinius-${rvm_ruby_version}";
            rvm_ruby_url="${rbx_url}/$rvm_ruby_package_file.${rvm_archive_extension}";
        fi;
    else
        rvm_ruby_repo_url=${rvm_rbx_repo_url:-$(__rvm_db "rbx_repo_url")};
        rvm_head_flag=1;
        rvm_ruby_patch_level="";
        rvm_ruby_tag="${rvm_ruby_version:+v}${rvm_ruby_version:-}";
        rvm_ruby_version="head";
        rvm_disable_binary_flag=1;
    fi;
    if [[ -n "${rvm_rbx_opt:-}" ]]; then
        export RBXOPT="${RBXOPT:=${rvm_rbx_opt}}";
    fi;
    true
}
__rvm_select_interpreter_ree () 
{ 
    rvm_ruby_interpreter=ree;
    rvm_ruby_version=${rvm_ruby_version:-"$(__rvm_db "ree_version")"};
    case "$rvm_ruby_version" in 
        1.8.*)
            true
        ;;
        *)
            rvm_error "Unknown Ruby Enterprise Edition version: $rvm_ruby_version"
        ;;
    esac;
    if [[ -n "${rvm_ruby_patch_level:-0}" ]]; then
        rvm_ruby_patch_level="${rvm_ruby_patch_level#p}";
    fi;
    rvm_ruby_package_file="ruby-enterprise-$rvm_ruby_version-$rvm_ruby_patch_level";
    rvm_ruby_url="$(__rvm_db "${rvm_ruby_interpreter}_${rvm_ruby_version}_${rvm_ruby_patch_level}_url")";
    rvm_ruby_url="${rvm_ruby_url:-$(__rvm_db "${rvm_ruby_interpreter}_${rvm_ruby_version}_url")}";
    rvm_ruby_url="${rvm_ruby_url}/$rvm_ruby_package_file.tar.gz";
    true
}
__rvm_select_interpreter_rubinius () 
{ 
    __rvm_select_interpreter_rbx || return $?
}
__rvm_select_interpreter_ruby () 
{ 
    if [[ "${rvm_ruby_patch_level:-}" == "p0" ]] && __rvm_version_compare "${rvm_ruby_version}" -ge 2.1.0 && [[ ! -d "$rvm_rubies_path/$rvm_ruby_string" ]]; then
        rvm_ruby_patch_level="";
        rvm_ruby_string="${rvm_ruby_string%-p0}";
    fi;
    rvm_ruby_package_name="${rvm_ruby_interpreter}-${rvm_ruby_version}${rvm_ruby_patch_level:+-}${rvm_ruby_patch_level:-}";
    rvm_ruby_package_file="${rvm_ruby_package_name}";
    if [[ -z "${rvm_ruby_version:-""}" ]] && (( ${rvm_head_flag:=0} == 0 )); then
        rvm_error "Ruby version was not specified!";
    else
        rvm_ruby_repo_url="${rvm_ruby_repo_url:-"$(__rvm_db "ruby_repo_url")"}";
        if (( ${rvm_head_flag:=0} == 0 )); then
            if __rvm_version_compare "${rvm_ruby_version}" -lt "1.8.5"; then
                rvm_archive_extension="tar.gz";
            else
                rvm_archive_extension="tar.bz2";
            fi;
        else
            rvm_disable_binary_flag=1;
        fi;
    fi;
    true
}
__rvm_select_interpreter_system () 
{ 
    true
}
__rvm_select_interpreter_topaz () 
{ 
    __rvm_select_interpreter_common "topaz"
}
__rvm_select_interpreter_user () 
{ 
    true
}
__rvm_select_interpreter_variables () 
{ 
    rvm_archive_extension="tar.gz";
    if [[ -z "${rvm_ruby_interpreter:-}" ]]; then
        rvm_ruby_interpreter="${rvm_ruby_string//-*/}";
    fi;
    rvm_ruby_interpreter="${rvm_ruby_interpreter:-missing}";
    if is_a_function __rvm_select_interpreter_${rvm_ruby_interpreter}; then
        __rvm_select_interpreter_${rvm_ruby_interpreter} || return $?;
    else
        if [[ -n "${MY_RUBY_HOME:-""}" ]]; then
            __rvm_select "${MY_RUBY_HOME##*/}" || return $?;
        else
            if [[ -z "${rvm_ruby_string:-""}" ]]; then
                rvm_error "Ruby implementation '$rvm_ruby_interpreter' is not known.";
                return 1;
            fi;
        fi;
    fi
}
__rvm_select_late () 
{ 
    if is_a_function __rvm_select_late_${rvm_ruby_interpreter}; then
        __rvm_select_late_${rvm_ruby_interpreter};
    fi
}
__rvm_select_late_rbx () 
{ 
    if { 
        [[ -n "${rvm_ruby_package_file:-}" && -f "${rvm_archives_path}/${rvm_ruby_package_file}" && -s "${rvm_archives_path}/${rvm_ruby_package_file}" ]]
    } || { 
        [[ -n "${rvm_ruby_url:-}" ]] && file_exists_at_url "${rvm_ruby_url}"
    } || { 
        [[ -n "${rbx_url:-}" && -n "${rvm_ruby_version:-}" ]] && __rvm_select_late_rbx_partial "${rbx_url}" "${rvm_ruby_version}"
    }; then
        rvm_head_flag=0;
    else
        rvm_head_flag=1;
        if [[ "${rvm_ruby_version}" == 'head' ]]; then
            true ${rvm_ruby_repo_branch:="master"};
        else
            true ${rvm_ruby_repo_branch:="master"} ${rvm_ruby_tag:="${rvm_ruby_version}"};
        fi;
    fi
}
__rvm_select_late_rbx_partial () 
{ 
    \typeset __found __ext __patern;
    __ext=".${rvm_archive_extension}";
    __patern="${2//\./\.}.*\.${rvm_archive_extension//\./\.}\$";
    __found="$(
    __rvm_curl -s $1/index.txt "rubinius-" |
    __rvm_awk -F"${__ext}" "/${__patern}/"'{print $1}' |
    __rvm_version_sort |
    __rvm_tail -n 1
  )";
    if [[ -n "${__found}" ]]; then
        rvm_ruby_version="${__found#rubinius-}";
        rvm_ruby_string="rbx-${rvm_ruby_version}";
        rvm_ruby_package_file="${__found}";
        rvm_ruby_url="$1/${__found}.${rvm_archive_extension}";
        return 0;
    else
        return 1;
    fi
}
__rvm_select_macruby_nightly () 
{ 
    __rvm_db "macruby_nightly_url" "rvm_ruby_url";
    case "${rvm_ruby_version:-}" in 
        nightly_*)
            __rvm_select_macruby_nightly_selected
        ;;
        *)
            __rvm_select_macruby_nightly_detect
        ;;
    esac;
    rvm_ruby_url+="/${rvm_ruby_package_file}";
    rvm_verify_downloads_flag=1;
    rvm_debug "selected macruby $rvm_ruby_string => $rvm_ruby_url";
    true
}
__rvm_select_macruby_nightly_detect () 
{ 
    \typeset __string_version;
    rvm_ruby_version="$(
    __rvm_curl -s "$rvm_ruby_url" |
    __rvm_grep -oE "<a href=\"macruby_nightly-[^<]+\.pkg</a>" |
    __rvm_awk -F"[<>]" '{print $3}' |
    __rvm_version_sort |
    __rvm_tail -n 1
  )";
    [[ -n "${rvm_ruby_version}" ]] || { 
        rvm_error "Could not find MacRuby nightly binary.";
        return 1
    };
    rvm_ruby_package_file="${rvm_ruby_version}";
    rvm_ruby_package_name="${rvm_ruby_package_file%.pkg}";
    __string_version="${rvm_ruby_package_name#macruby_nightly-}";
    __string_version="${__string_version//-/.}";
    rvm_ruby_version="nightly_${__string_version}";
    rvm_ruby_string="macruby-${rvm_ruby_version}${rvm_ruby_name:+-}${rvm_ruby_name:-}";
    true
}
__rvm_select_macruby_nightly_selected () 
{ 
    \typeset __string_version;
    __string_version="${rvm_ruby_version//./-}";
    __string_version="${__string_version#nightly_}";
    rvm_ruby_package_name="${rvm_ruby_interpreter}_nightly-${__string_version}";
    rvm_ruby_package_file="$rvm_ruby_package_name.pkg"
}
__rvm_select_rbx_compatibility_branch () 
{ 
    case "${rvm_ruby_version}" in 
        2.0pre)
            rvm_ruby_repo_branch="master"
        ;;
        2.0.testing)
            rvm_ruby_repo_branch="${rvm_ruby_version}"
        ;;
    esac;
    if [[ ${rvm_19_flag:-0} == 1 ]]; then
        rvm_ruby_repo_branch="1.9.3";
        rvm_head_flag=1;
    else
        if [[ ${rvm_18_flag:-0} == 1 ]]; then
            rvm_ruby_repo_branch="1.8.7";
            rvm_head_flag=1;
        fi;
    fi;
    true
}
__rvm_select_rbx_nightly () 
{ 
    (( ${rvm_nightly_flag:=0} == 1 )) || return 0;
    \typeset org_rvm_ruby_patch_level _rvm_ruby_name;
    if [[ "$rvm_ruby_version" == head ]]; then
        rvm_ruby_version="";
    fi;
    rvm_debug "searching for binary rbx ${rvm_ruby_version:-}${rvm_ruby_version:+-}${rvm_ruby_patch_level}*${rvm_ruby_name:+-}${rvm_ruby_name:-}";
    org_rvm_ruby_patch_level="$rvm_ruby_patch_level";
    _rvm_ruby_name="${rvm_ruby_name:-${detected_rvm_ruby_name:-}}";
    rvm_ruby_patch_level="$(
    __list_remote_all |
      __rvm_grep ${rvm_ruby_version:-}${rvm_ruby_version:+-}${org_rvm_ruby_patch_level}.*${_rvm_ruby_name:+-}${_rvm_ruby_name:-} |
      __rvm_tail -n 1
  )";
    [[ -n "${rvm_ruby_patch_level:-}" ]] || { 
        rvm_error "Could not find rbx binary '${rvm_ruby_version:-}${rvm_ruby_version:+-}${org_rvm_ruby_patch_level}*${rvm_ruby_name:+-}${rvm_ruby_name:-}' binary release.";
        return 1
    };
    rvm_ruby_patch_level="${rvm_ruby_patch_level##*/}";
    rvm_ruby_patch_level="${rvm_ruby_patch_level%.tar.*}";
    if [[ -z "${rvm_ruby_version:-}" ]]; then
        rvm_ruby_patch_level="${rvm_ruby_patch_level#rubinius-}";
        rvm_ruby_version="${rvm_ruby_patch_level%%-*}";
    fi;
    if [[ -z "${rvm_ruby_name:-}" ]]; then
        rvm_ruby_name="${rvm_ruby_patch_level##*-}";
    fi;
    rvm_ruby_patch_level="${rvm_ruby_patch_level##*${org_rvm_ruby_patch_level}}";
    rvm_ruby_patch_level="${rvm_ruby_patch_level%%-*}";
    rvm_ruby_patch_level="${org_rvm_ruby_patch_level}${rvm_ruby_patch_level}";
    rvm_ruby_string="rubinius-${rvm_ruby_version}-${rvm_ruby_patch_level}-${rvm_ruby_name}";
    rvm_debug "detected rbx ${rvm_ruby_string}";
    rvm_verify_downloads_flag=1;
    true
}
__rvm_select_set_variable_defaults () 
{ 
    export GEM_HOME GEM_PATH MY_RUBY_HOME RUBY_VERSION IRBRC;
    export rvm_env_string rvm_action rvm_alias_expanded rvm_archive_extension rvm_bin_flag rvm_bin_path rvm_debug_flag rvm_default_flag rvm_delete_flag rvm_docs_type rvm_dump_environment_flag rvm_error_message rvm_expanding_aliases rvm_file_name rvm_gemdir_flag rvm_gemset_name rvm_gemstone_package_file rvm_gemstone_url rvm_head_flag rvm_hook rvm_install_on_use_flag rvm_llvm_flag rvm_loaded_flag rvm_niceness rvm_nightly_flag rvm_only_path_flag rvm_parse_break rvm_patch_original_pwd rvm_pretty_print_flag rvm_proxy rvm_quiet_flag rvm_reload_flag rvm_remove_flag rvm_ruby_alias rvm_ruby_args rvm_ruby_binary rvm_ruby_bits rvm_ruby_configure rvm_ruby_file rvm_ruby_gem_home rvm_ruby_gem_path rvm_ruby_global_gems_path rvm_ruby_home rvm_ruby_interpreter rvm_ruby_irbrc rvm_ruby_major_version rvm_ruby_make rvm_ruby_make_install rvm_ruby_minor_version rvm_ruby_mode rvm_ruby_name rvm_ruby_package_file rvm_ruby_package_name rvm_ruby_patch rvm_ruby_patch_level rvm_ruby_release_version rvm_ruby_repo_url rvm_ruby_revision rvm_ruby_selected_flag rvm_ruby_sha rvm_ruby_string rvm_ruby_strings rvm_ruby_tag rvm_ruby_url rvm_ruby_user_tag rvm_ruby_version rvm_script_name rvm_sdk rvm_silent_flag rvm_sticky_flag rvm_system_flag rvm_token rvm_trace_flag rvm_use_flag rvm_user_flag rvm_verbose_flag rvm_wrapper_name
}
__rvm_select_version_variables () 
{ 
    case "$rvm_ruby_version" in 
        +([0-9]).+([0-9]).+([0-9]))
            rvm_ruby_release_version="${rvm_ruby_version/.*/}";
            rvm_ruby_major_version=${rvm_ruby_version%.*};
            rvm_ruby_major_version=${rvm_ruby_major_version#*.};
            rvm_ruby_minor_version="${rvm_ruby_version//*.}"
        ;;
        +([0-9]).+([0-9]))
            rvm_ruby_release_version="${rvm_ruby_version/.*/}";
            rvm_ruby_major_version="${rvm_ruby_version#*.}";
            rvm_ruby_minor_version=""
        ;;
    esac
}
__rvm_set_color () 
{ 
    \typeset __buffer __variable;
    __buffer='[';
    __variable="$1";
    shift;
    while (( $# )); do
        __rvm_set_color_single "$1";
        shift;
        if (( $# )); then
            __buffer+=';';
        fi;
    done;
    __buffer+='m';
    if [[ "${__variable}" == "" || "${__variable}" == "print" ]]; then
        printf "${__buffer}";
    else
        eval "${__variable}='${__buffer}'";
    fi
}
__rvm_set_color_single () 
{ 
    case "$1" in 
        bold)
            __buffer+='7'
        ;;
        offbold)
            __buffer+='27'
        ;;
        black)
            __buffer+='30'
        ;;
        red)
            __buffer+='31'
        ;;
        green)
            __buffer+='32'
        ;;
        yellow)
            __buffer+='33'
        ;;
        blue)
            __buffer+='34'
        ;;
        magenta)
            __buffer+='35'
        ;;
        cyan)
            __buffer+='36'
        ;;
        white)
            __buffer+='37'
        ;;
        default)
            __buffer+='39'
        ;;
        bblack)
            __buffer+='40'
        ;;
        bred)
            __buffer+='41'
        ;;
        bgreen)
            __buffer+='42'
        ;;
        byellow)
            __buffer+='43'
        ;;
        bblue)
            __buffer+='44'
        ;;
        bmagenta)
            __buffer+='45'
        ;;
        bcyan)
            __buffer+='46'
        ;;
        bwhite)
            __buffer+='47'
        ;;
        bdefault)
            __buffer+='49'
        ;;
        *)
            __buffer+='0'
        ;;
    esac
}
__rvm_set_env () 
{ 
    \typeset __save_to __set __key __value;
    __save_to="$1";
    shift;
    for __set in "$@";
    do
        __key="${__set%%=*}";
        __value="${__set#*=}";
        case "$__value" in 
            \"*\")
                __value="${__value#\"}";
                __value="${__value%\"}"
            ;;
            \'*\')
                __value="${__value#\'}";
                __value="${__value%\'}"
            ;;
        esac;
        rvm_debug "key=$__key; value=$__value;";
        if [[ -n "${__save_to}" ]]; then
            eval "${__save_to}+=( \"\${__key}=\${${__key}}\" )";
        fi;
        if [[ -n "${__value}" ]]; then
            eval "export \${__key}=\"\${__value}\"";
        else
            eval "unset \${__key}";
        fi;
    done
}
__rvm_set_executable () 
{ 
    for __file in "$@";
    do
        [[ -x "${__file}" ]] || chmod +x "${__file}";
    done
}
__rvm_set_ruby_version () 
{ 
    if [[ -s .ruby-version ]]; then
        \command \mv .ruby-version .ruby-version.$(__rvm_date +%m.%d.%Y-%H:%M:%S);
        rvm_warn ".ruby-version is not empty, moving aside to preserve.";
    fi;
    \typeset __version="$(__rvm_env_string)";
    case "${__version}" in 
        *@*)
            if [[ -s .ruby-gemset ]]; then
                \command \mv .ruby-gemset .ruby-gemset.$(__rvm_date +%m.%d.%Y-%H:%M:%S);
                rvm_warn ".ruby-gemset is not empty, moving aside to preserve.";
            fi;
            echo "${__version##*@}" > .ruby-gemset
        ;;
        *)
            if [[ -s .ruby-gemset ]]; then
                \command \mv .ruby-gemset .ruby-gemset.$(__rvm_date +%m.%d.%Y-%H:%M:%S);
                rvm_warn ".ruby-gemset not needed, moving aside to preserve.";
            fi
        ;;
    esac;
    echo "${__version%@*}" > .ruby-version
}
__rvm_set_rvmrc () 
{ 
    \typeset flags identifier short_identifier gem_file;
    true ${rvm_verbose_flag:=0};
    if [[ "$HOME" != "$PWD" && "${rvm_prefix:-}" != "$PWD" ]]; then
        if (( rvm_verbose_flag )); then
            flags="use ";
        fi;
        if [[ -s .rvmrc ]]; then
            \command \mv .rvmrc .rvmrc.$(__rvm_date +%m.%d.%Y-%H:%M:%S);
            rvm_warn ".rvmrc is not empty, moving aside to preserve.";
        fi;
        identifier=$(__rvm_env_string);
        short_identifier="${identifier#ruby-}";
        short_identifier="${short_identifier%%-*}";
        printf "%b" "#!/usr/bin/env bash

# This is an RVM Project .rvmrc file, used to automatically load the ruby
# development environment upon cd'ing into the directory

# First we specify our desired <ruby>[@<gemset>], the @gemset name is optional,
# Only full ruby name is supported here, for short names use:
#     echo \"rvm use ${short_identifier}\" > .rvmrc
environment_id=\"$identifier\"

# Uncomment the following lines if you want to verify rvm version per project
# rvmrc_rvm_version=\"${rvm_version}\" # 1.10.1 seems like a safe start
# eval \"\$(echo \${rvm_version}.\${rvmrc_rvm_version} | __rvm_awk -F. '{print \"[[ \"\$1*65536+\$2*256+\$3\" -ge \"\$4*65536+\$5*256+\$6\" ]]\"}' )\" || {
#   echo \"This .rvmrc file requires at least RVM \${rvmrc_rvm_version}, aborting loading.\"
#   return 1
# }
" >> .rvmrc;
        if __rvm_string_match "$identifier" "jruby*"; then
            printf "%b" "
# Uncomment following line if you want options to be set only for given project.
# PROJECT_JRUBY_OPTS=( --1.9 )
# The variable PROJECT_JRUBY_OPTS requires the following to be run in shell:
#    chmod +x \${rvm_path}/hooks/after_use_jruby_opts
" >> .rvmrc;
        fi;
        printf "%b" "
# First we attempt to load the desired environment directly from the environment
# file. This is very fast and efficient compared to running through the entire
# CLI and selector. If you want feedback on which environment was used then
# insert the word 'use' after --create as this triggers verbose mode.
if [[ -d \"\${rvm_path:-\$HOME/.rvm}/environments\"
  && -s \"\${rvm_path:-\$HOME/.rvm}/environments/\$environment_id\" ]]
then
  \\. \"\${rvm_path:-\$HOME/.rvm}/environments/\$environment_id\"
  for __hook in \"\${rvm_path:-\$HOME/.rvm}/hooks/after_use\"*
  do
    if [[ -f \"\${__hook}\" && -x \"\${__hook}\" && -s \"\${__hook}\" ]]
    then \\. \"\${__hook}\" || true
    fi
  done
  unset __hook
" >> .rvmrc;
        if [[ " $flags " == *" use "* ]]; then
            printf "%b" "  if (( \${rvm_use_flag:=1} >= 1 )) # display automatically" >> .rvmrc;
        else
            printf "%b" "  if (( \${rvm_use_flag:=1} >= 2 )) # display only when forced" >> .rvmrc;
        fi;
        printf "%b" "
  then
    if [[ \$- == *i* ]] # check for interactive shells
    then printf \"%b\" \"Using: \$(tput setaf 2 2>/dev/null)\$GEM_HOME\$(tput sgr0 2>/dev/null)\\\\n\" # show the user the ruby and gemset they are using in green
    else printf \"%b\" \"Using: \$GEM_HOME\\\\n\" # don't use colors in non-interactive shells
    fi
  fi
" >> .rvmrc;
        printf "%b" "else
  # If the environment file has not yet been created, use the RVM CLI to select.
  rvm --create $flags \"\$environment_id\" || {
    echo \"Failed to create RVM environment '\${environment_id}'.\"
    return 1
  }
fi
" >> .rvmrc;
        for gem_file in *.gems;
        do
            case "$gem_file" in 
                \*.gems)
                    continue
                ;;
            esac;
            printf "%b" "
# If you use an RVM gemset file to install a list of gems (*.gems), you can have
# it be automatically loaded. Uncomment the following and adjust the filename if
# necessary.
#
# filename=\".gems\"
# if [[ -s \"\$filename\" ]]
# then
#   rvm gemset import \"\$filename\" | GREP_OPTIONS=\"\" \\\\command \\grep -v already | GREP_OPTIONS=\"\" \command \grep -v listed | GREP_OPTIONS=\"\" \command \grep -v complete | \command \sed '/^$/d'
# fi
" >> .rvmrc;
        done;
        if [[ -s Gemfile ]]; then
            printf "%b" "
# If you use bundler, this might be useful to you:
# if [[ -s Gemfile ]] && {
#   ! builtin command -v bundle >/dev/null ||
#   builtin command -v bundle | GREP_OPTIONS=\"\" \\\\command \\grep \$rvm_path/bin/bundle >/dev/null
# }
# then
#   printf \"%b\" \"The rubygem 'bundler' is not installed. Installing it now.\\\\n\"
#   gem install bundler
# fi
# if [[ -s Gemfile ]] && builtin command -v bundle >/dev/null
# then
#   bundle install | GREP_OPTIONS=\"\" \\\\command \\grep -vE '^Using|Your bundle is complete'
# fi
" >> .rvmrc;
        fi;
    else
        rvm_error ".rvmrc cannot be set in your home directory.      \nThe home .rvmrc is for global rvm settings only.";
    fi
}
__rvm_set_versions_conf () 
{ 
    \typeset gemset identifier;
    if [[ -s .versions.conf ]]; then
        \command \mv .versions.conf .versions.conf.$(__rvm_date +%m.%d.%Y-%H:%M:%S);
        rvm_warn ".version.conf is not empty, moving aside to preserve.";
    fi;
    identifier=$(__rvm_env_string);
    gemset=${identifier#*@};
    identifier=${identifier%@*};
    printf "%b" "ruby=$identifier
" >> .versions.conf;
    if [[ -n "$gemset" && "$gemset" != "$identifier" ]]; then
        printf "%b" "ruby-gemset=$gemset
" >> .versions.conf;
    else
        printf "%b" "#ruby-gemset=my-projectit
" >> .versions.conf;
    fi;
    printf "%b" "#ruby-gem-install=bundler rake
#ruby-bundle-install=true
" >> .versions.conf
}
__rvm_setup () 
{ 
    __variables_definition export;
    if (( __rvm_env_loaded != 1 )); then
        return 0;
    fi;
    if [[ -n "${BASH_VERSION:-}" ]] && ! __function_on_stack cd pushd popd; then
        export rvm_shell_nounset;
        if __rvm_has_opt "nounset"; then
            rvm_bash_nounset=1;
        else
            rvm_bash_nounset=0;
        fi;
        set +o nounset;
        trap '__rvm_teardown_final ; set +x' EXIT HUP INT QUIT TERM;
    fi;
    if [[ -n "${ZSH_VERSION:-}" ]]; then
        export rvm_zsh_clobber rvm_zsh_nomatch;
        if setopt | __rvm_grep -s '^noclobber$' > /dev/null 2>&1; then
            rvm_zsh_clobber=0;
        else
            rvm_zsh_clobber=1;
        fi;
        setopt clobber;
        if setopt | __rvm_grep -s '^nonomatch$' > /dev/null 2>&1; then
            rvm_zsh_nomatch=0;
        else
            rvm_zsh_nomatch=1;
        fi;
        setopt no_nomatch;
    fi
}
__rvm_setup_statf_function () 
{ 
    if [[ "${_system_type}" == Darwin || "${_system_type}" == BSD ]]; then
        function __rvm_statf () 
        { 
            __rvm_stat -f "$2" "$3"
        };
    else
        function __rvm_statf () 
        { 
            __rvm_stat -c "$1" "$3"
        };
    fi
}
__rvm_setup_sudo_function () 
{ 
    if is_a_function __rvm_setup_sudo_function_${_system_name}; then
        __rvm_setup_sudo_function_${_system_name} "$@" || return $?;
    else
        __rvm_setup_sudo_function_Other "$@" || return $?;
    fi
}
__rvm_setup_sudo_function_Other () 
{ 
    if __rvm_which sudo > /dev/null 2>&1; then
        function __rvm_sudo () 
        { 
            \command \sudo "$@"
        };
    else
        rvm_debug "Warning: No 'sudo' found.";
    fi
}
__rvm_setup_sudo_function_PCLinuxOS () 
{ 
    function __rvm_sudo () 
    { 
        if [[ "$1" == "-p" ]]; then
            rvm_printf_to_stderr "${2//%p/[root]/}";
            shift 2;
        fi;
        su -c "$*"
    }
}
__rvm_setup_sudo_function_Solaris () 
{ 
    if [[ -x /opt/csw/bin/sudo ]]; then
        function __rvm_sudo () 
        { 
            /opt/csw/bin/sudo "$@"
        };
    else
        if [[ -x /usr/bin/sudo ]]; then
            function __rvm_sudo () 
            { 
                /usr/bin/sudo "$@"
            };
        else
            rvm_debug "Warning: No '/opt/csw/bin/sudo' found.";
        fi;
    fi
}
__rvm_setup_utils_functions () 
{ 
    \typeset gnu_tools_path gnu_prefix gnu_util;
    \typeset -a gnu_utils gnu_missing;
    gnu_utils=(awk cp date find sed tail tar xargs);
    gnu_missing=();
    if is_a_function __rvm_setup_utils_functions_${_system_name}; then
        __rvm_setup_utils_functions_${_system_name} "$@" || return $?;
    else
        __rvm_setup_utils_functions_Other "$@" || return $?;
    fi
}
__rvm_setup_utils_functions_OSX () 
{ 
    if [[ -x /usr/bin/stat ]]; then
        function __rvm_stat () 
        { 
            /usr/bin/stat "$@" || return $?
        };
    else
        rvm_error "ERROR: Missing (executable) /usr/bin/stat. Falling back to '\\\\command \\\\stat' which might be something else.";
        function __rvm_stat () 
        { 
            \command \stat "$@" || return $?
        };
    fi;
    __rvm_setup_utils_functions_common
}
__rvm_setup_utils_functions_Other () 
{ 
    function __rvm_stat () 
    { 
        \command \stat "$@" || return $?
    };
    __rvm_setup_utils_functions_common
}
__rvm_setup_utils_functions_Solaris () 
{ 
    case "${_system_version}" in 
        10)
            gnu_tools_path=/opt/csw/bin;
            gnu_prefix="g"
        ;;
        11)
            gnu_tools_path=/usr/gnu/bin;
            gnu_prefix=""
        ;;
    esac;
    if [[ -x $gnu_tools_path/${gnu_prefix}grep ]]; then
        eval "__rvm_grep() { GREP_OPTIONS=\"\" $gnu_tools_path/${gnu_prefix}grep \"\$@\" || return \$?; }";
    else
        gnu_missing+=(${gnu_prefix}grep);
    fi;
    if [[ "${_system_name}" == "OpenIndiana" || "${_system_version}" == "11" ]]; then
        function __rvm_stat () 
        { 
            \command \stat "$@" || return $?
        };
    else
        if [[ -x $gnu_tools_path/${gnu_prefix}stat ]]; then
            eval "__rvm_stat() { $gnu_tools_path/${gnu_prefix}stat \"\$@\" || return \$?; }";
        else
            gnu_missing+=(${gnu_prefix}stat);
        fi;
    fi;
    if [[ "${_system_name}" == "SmartOS" ]]; then
        function __rvm_which () 
        { 
            \command \which "$@" || return $?
        };
    else
        if [[ -x $gnu_tools_path/${gnu_prefix}which ]]; then
            eval "__rvm_which() { $gnu_tools_path/${gnu_prefix}which \"\$@\" || return \$?; }";
        else
            gnu_missing+=(${gnu_prefix}which);
        fi;
    fi;
    for gnu_util in "${gnu_utils[@]}";
    do
        if [[ -x $gnu_tools_path/$gnu_prefix$gnu_util ]]; then
            eval "__rvm_$gnu_util() { $gnu_tools_path/$gnu_prefix$gnu_util \"\$@\" || return \$?; }";
        else
            gnu_missing+=($gnu_prefix$gnu_util);
        fi;
    done;
    if (( ${#gnu_missing[@]} )); then
        rvm_error "ERROR: Missing GNU tools: ${gnu_missing[@]}. Make sure they are installed in '$gnu_tools_path/' before using RVM!";
        if [[ "${_system_name} ${_system_version}" == "Solaris 10" ]]; then
            rvm_error "You might want to look at OpenCSW project to install the above mentioned tools (https://www.opencsw.org/about)";
        fi;
        exit 200;
    fi
}
__rvm_setup_utils_functions_common () 
{ 
    function __rvm_grep () 
    { 
        GREP_OPTIONS="" \command \grep "$@" || return $?
    };
    if \command \which --skip-alias --skip-functions which > /dev/null 2>&1; then
        function __rvm_which () 
        { 
            \command \which --skip-alias --skip-functions "$@" || return $?
        };
    else
        if \command \which whence > /dev/null 2>&1 && \command \whence whence > /dev/null 2>&1; then
            function __rvm_which () 
            { 
                \command \whence -p "$@" || return $?
            };
        else
            if \command \which which > /dev/null 2>&1; then
                function __rvm_which () 
                { 
                    \command \which "$@" || return $?
                };
            else
                if \which which > /dev/null 2>&1; then
                    function __rvm_which () 
                    { 
                        \which "$@" || return $?
                    };
                else
                    \typeset __result=$?;
                    rvm_error "ERROR: Missing proper 'which' command. Make sure it is installed before using RVM!";
                    return ${__result};
                fi;
            fi;
        fi;
    fi;
    for gnu_util in "${gnu_utils[@]}";
    do
        eval "__rvm_$gnu_util() { \\$gnu_util \"\$@\" || return \$?; }";
    done
}
__rvm_sha256_for_contents () 
{ 
    if builtin command -v sha256sum > /dev/null; then
        sha256sum | __rvm_awk '{print $1}';
    else
        if builtin command -v sha256 > /dev/null; then
            sha256 | __rvm_awk '{print $1}';
        else
            if builtin command -v shasum > /dev/null; then
                shasum -a256 | __rvm_awk '{print $1}';
            else
                if builtin command -v openssl > /dev/null; then
                    openssl sha -sha256 | __rvm_awk '{print $1}';
                else
                    return 1;
                fi;
            fi;
        fi;
    fi;
    true
}
__rvm_sha__calculate () 
{ 
    rvm_debug "Calculate sha512 checksum for $@";
    \typeset bits _sum;
    bits=${1:-512};
    shift;
    if builtin command -v sha${bits}sum > /dev/null; then
        _sum=$(sha${bits}sum    "$@");
        echo ${_sum% *};
        return 0;
    else
        if builtin command -v sha${bits} > /dev/null; then
            _sum=$(sha${bits}       "$@");
            if [[ "${_sum%% *}" == "SHA${bits}" ]]; then
                echo ${_sum##* };
            else
                echo ${_sum% *};
            fi;
            return 0;
        else
            if builtin command -v shasum > /dev/null; then
                _sum=$(shasum -a${bits} "$@");
                echo ${_sum% *};
                return 0;
            else
                if builtin command -v /opt/csw/bin/shasum > /dev/null; then
                    _sum=$(/opt/csw/bin/shasum -a${bits} "$@");
                    echo ${_sum% *};
                    return 0;
                fi;
            fi;
        fi;
    fi;
    rvm_error "Neither sha512sum nor shasum found in the PATH";
    return 1
}
__rvm_stat () 
{ 
    \command \stat "$@" || return $?
}
__rvm_statf () 
{ 
    __rvm_stat -f "$2" "$3"
}
__rvm_string_includes () 
{ 
    \typeset __search __text="$1";
    shift;
    for __search in "$@";
    do
        if [[ " ${__text} " == *" ${__search} "* ]]; then
            return 0;
        fi;
    done;
    return 1
}
__rvm_string_match () 
{ 
    \typeset _string;
    _string="$1";
    shift;
    while (( $# )); do
        case "${_string}" in 
            ${1// /[[:space:]]})
                return 0
            ;;
        esac;
        shift;
    done;
    return 1
}
__rvm_strings () 
{ 
    \typeset strings ruby_strings;
    ruby_strings=($(echo ${rvm_ruby_args:-$rvm_ruby_string}));
    for rvm_ruby_string in "${ruby_strings[@]}";
    do
        strings="$strings $(__rvm_select ; echo $rvm_ruby_string)";
    done;
    echo $strings;
    return 0
}
__rvm_strip () 
{ 
    __rvm_sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/[[:space:]]\{1,\}/ /g';
    return $?
}
__rvm_sudo () 
{ 
    \command \sudo "$@"
}
__rvm_switch () 
{ 
    \typeset new_rvm_path new_rvm_bin_path;
    (( $# )) && [[ -z "$1" ]] && shift || true;
    (( $# )) && [[ -n "$1" ]] && [[ -d "$1" || -d "${1%/*}" ]] && [[ ! -f "$1" ]] || { 
        rvm_error "No valid path given.";
        return 1
    };
    [[ "${rvm_path}" != "${new_rvm_path}" ]] || { 
        rvm_warn "Already there!";
        return 2
    };
    rvm_log "Switching ${rvm_path} => ${1}";
    new_rvm_path="${1%/}";
    new_rvm_bin_path="${2:-$new_rvm_path/bin}";
    new_rvm_bin_path="${new_rvm_bin_path%/}";
    __rvm_use_system;
    __rvm_remove_from_path "${rvm_path%/}/*";
    rvm_reload_flag=1;
    rvm_path="${new_rvm_path}";
    rvm_bin_path="${new_rvm_bin_path}";
    rvm_scripts_path="${rvm_path}/scripts";
    rvm_environments_path="${rvm_path}/environments";
    __rvm_remove_from_path "${rvm_path%/}/*";
    __rvm_add_to_path prepend "${rvm_bin_path}"
}
__rvm_system_path () 
{ 
    rvm_remote_server_path="$(__rvm_db "rvm_remote_server_path${2:-}")";
    [[ -n "${rvm_remote_server_path}" ]] || rvm_remote_server_path="${_system_name_lowercase}/${_system_version}/${_system_arch}";
    if [[ "${1:-}" == "-" ]]; then
        printf "%b" "${rvm_remote_server_path}\n";
    fi
}
__rvm_table () 
{ 
    if [[ -n "${1:-}" ]]; then
        __rvm_table_br;
        echo "$1" | __rvm_table_wrap_text;
    fi;
    __rvm_table_br;
    \command \cat "${2:--}" | __rvm_table_wrap_text;
    __rvm_table_br
}
__rvm_table_br () 
{ 
    \typeset width=${COLUMNS:-78};
    width=$(( width > 116 ? 116 : width ));
    printf "%-${width}s\n" " " | __rvm_sed 's/ /*/g'
}
__rvm_table_wrap_text () 
{ 
    \typeset width=${COLUMNS:-78};
    width=$(( width > 116 ? 116 : width ));
    width=$(( width - 4 ));
    __rvm_fold $width | __rvm_awk -v width=$width '{printf "* %-"width"s *\n", $0}'
}
__rvm_tail () 
{ 
    \tail "$@" || return $?
}
__rvm_take_n () 
{ 
    \typeset IFS __temp_counter;
    \typeset -a __temp_arr1 __temp_arr2;
    IFS=$3;
    if [[ -n "${ZSH_VERSION:-}" ]]; then
        eval "__temp_arr1=( \${=$1} )";
    else
        eval "__temp_arr1=( \$$1 )";
    fi;
    __temp_counter=0;
    __temp_arr2=();
    while (( __temp_counter < $2 )); do
        __temp_arr2+=("${__temp_arr1[__array_start+__temp_counter++]}");
    done;
    eval "$1=\"\${__temp_arr2[*]}\""
}
__rvm_tar () 
{ 
    \tar "$@" || return $?
}
__rvm_teardown () 
{ 
    if builtin command -v __rvm_cleanup_tmp > /dev/null 2>&1; then
        __rvm_cleanup_tmp;
    fi;
    export __rvm_env_loaded;
    : __rvm_env_loaded:${__rvm_env_loaded:=${rvm_tmp_path:+1}}:;
    : __rvm_env_loaded:${__rvm_env_loaded:=0}:;
    : __rvm_env_loaded:$(( __rvm_env_loaded-=1 )):;
    if [[ -z "${rvm_tmp_path:-}" ]] || (( __rvm_env_loaded > 0 )); then
        return 0;
    fi;
    if [[ -n "${BASH_VERSION:-}" ]]; then
        trap - EXIT HUP INT QUIT TERM;
        if is_a_function shell_session_update; then
            trap 'shell_session_update' EXIT;
        fi;
        (( rvm_bash_nounset == 1 )) && set -o nounset;
        unset rvm_bash_nounset;
    fi;
    if [[ -n "${ZSH_VERSION:-""}" ]]; then
        (( rvm_zsh_clobber == 0 )) && setopt noclobber;
        (( rvm_zsh_nomatch == 0 )) || setopt nomatch;
        unset rvm_zsh_clobber rvm_zsh_nomatch;
    fi;
    if [[ -n "${rvm_stored_umask:-}" ]]; then
        umask ${rvm_stored_umask};
        unset rvm_stored_umask;
    fi;
    if builtin command -v __rvm_cleanup_download > /dev/null 2>&1; then
        __rvm_cleanup_download;
    fi;
    if [[ "${rvm_stored_errexit:-""}" == "1" ]]; then
        set -e;
    fi;
    __variables_definition unset;
    return 0
}
__rvm_teardown_final () 
{ 
    __rvm_env_loaded=1;
    unset __rvm_project_rvmrc_lock;
    __rvm_teardown
}
__rvm_teardown_if_broken () 
{ 
    if __function_on_stack __rvm_load_project_config || __function_on_stack __rvm_with; then
        true;
    else
        if (( ${__rvm_env_loaded:-0} > 0 )); then
            __rvm_teardown_final;
        fi;
    fi
}
__rvm_trust_rvmrc () 
{ 
    [[ -f "$1" ]] || return 1;
    __rvm_reset_rvmrc_trust "$1";
    __rvm_db_ "${rvm_user_path:-${rvm_path}/user}/rvmrcs" "$(__rvm_rvmrc_key "$1")" "1;$(__rvm_checksum_for_contents "$1")" > /dev/null 2>&1 || return $?
}
__rvm_try_sudo () 
{ 
    ( \typeset -a command_to_run;
    \typeset sudo_path sbin_path missing_paths;
    command_to_run=("$@");
    (( UID == 0 )) || case "$rvm_autolibs_flag_number" in 
        0)
            rvm_debug "Running '$*' would require sudo.";
            return 0
        ;;
        1)
            rvm_warn "Running '$*' would require sudo.";
            return 0
        ;;
        2)
            rvm_requiremnts_fail error "Running '$*' would require sudo.";
            return 1
        ;;
        *)
            if is_a_function __rvm_sudo; then
                missing_paths="";
                for sbin_path in /sbin /usr/sbin /usr/local/sbin;
                do
                    if [[ -d "${sbin_path}" ]] && [[ ":$PATH:" != *":${sbin_path}:"* ]]; then
                        missing_paths+=":${sbin_path}";
                    fi;
                done;
                if [[ -n "${missing_paths}" ]]; then
                    command_to_run=(/usr/bin/env PATH="${PATH}${missing_paths}" "${command_to_run[@]}");
                fi;
                command_to_run=(__rvm_sudo -p "%p password required for '$*': " "${command_to_run[@]}");
            else
                rvm_error "Running '$*' would require sudo, but 'sudo' is not found!";
                return 1;
            fi
        ;;
    esac;
    "${command_to_run[@]}" || return $? )
}
__rvm_unload () 
{ 
    \typeset _element;
    \typeset -a _list;
    __rvm_remove_rvm_from_path;
    if [[ -n "${ZSH_VERSION:-}" ]]; then
        __rvm_remove_from_array fpath "$rvm_path/scripts/extras/completion.zsh" "${fpath[@]}";
    fi;
    __rvm_unload_action unalias <<< $'"$(\n    if [[ -n "${ZSH_VERSION:-}" ]]\n    then alias | __rvm_awk -F"=" \'/rvm/ {print $1}\'\n    else alias | __rvm_awk -F"[= ]" \'/rvm/ {print $2}\'\n    fi\n  )"';
    __rvm_unload_action unset <<< $'"$(\n    set |\n      __rvm_awk -F"=" \'BEGIN{v=0;} /^[a-zA-Z_][a-zA-Z0-9_]*=/{v=1;} v==1&&$2~/^[\'\\\'\'\\$]/{v=2;}\n        v==1&&$2~/^\\(/{v=3;} v==2&&/\'\\\'\'$/&&!/\'\\\'\\\'\'$/{v=1;} v==3&&/\\)$/{v=1;} v{print;} v==1{v=0;}\' |\n      __rvm_awk -F"=" \'/^[^ ]*(RUBY|GEM|IRB|gem|rubies|rvm)[^ ]*=/ {print $1} /^[^ ]*=.*rvm/ {print $1}\' |\n      __rvm_grep -vE "^PROMPT|^prompt|^PS|^BASH_SOURCE|^PATH"\n  )"';
    __rvm_unload_action __function_unset <<< $'"$(\n    \\typeset -f | __rvm_awk \'$2=="()" {fun=$1} /rvm/{print fun}\' | sort -u | __rvm_grep -v __rvm_unload_action\n  )"';
    if [[ -n "${ZSH_VERSION:-}" ]]; then
        unset -f __rvm_unload_action;
        unset -f __function_unset;
        if [[ -n "${_comp_dumpfile:-}" ]]; then
            \command \rm -f "$_comp_dumpfile";
            compinit -d "$_comp_dumpfile";
        fi;
    else
        unset __rvm_unload_action __function_unset;
    fi
}
__rvm_unload_action () 
{ 
    \typeset _element IFS;
    \typeset -a _list;
    IFS='
';
    _list=($( \command \cat ${2:--} | sort -u ));
    for _element in "${_list[@]}";
    do
        $1 "${_element}";
    done
}
__rvm_unset_exports () 
{ 
    \typeset wrap_name name value;
    \typeset -a __variables_list;
    __rvm_read_lines __variables_list <<< $'"$(\n    printenv | __rvm_sed \'/^rvm_old_.*=/ { s/=.*$//; p; }; d;\'\n  )"';
    for wrap_name in "${__variables_list[@]}";
    do
        eval "value=\"\${${wrap_name}}\"";
        name=${wrap_name#rvm_old_};
        if [[ -n "${value:-}" ]]; then
            export $name="${value}";
        else
            unset $name;
        fi;
        unset $wrap_name;
    done
}
__rvm_unset_ruby_variables () 
{ 
    unset rvm_env_string rvm_ruby_string rvm_ruby_strings rvm_ruby_binary rvm_ruby_gem_home rvm_ruby_gem_path rvm_ruby_home rvm_ruby_interpreter rvm_ruby_irbrc rvm_ruby_log_path rvm_ruby_major_version rvm_ruby_minor_version rvm_ruby_package_name rvm_ruby_patch_level rvm_ruby_release_version rvm_ruby_repo_url rvm_ruby_repo_branch rvm_ruby_revision rvm_ruby_selected_flag rvm_ruby_tag rvm_ruby_version rvm_head_flag rvm_ruby_package_file rvm_ruby_configure rvm_ruby_name rvm_ruby_url rvm_ruby_global_gems_path rvm_ruby_args rvm_ruby_name rvm_llvm_flag;
    __rvm_load_rvmrc
}
__rvm_untrust_rvmrc () 
{ 
    [[ -f "$1" ]] || return 1;
    __rvm_reset_rvmrc_trust "$1";
    __rvm_db_ "${rvm_user_path:-${rvm_path}/user}/rvmrcs" "$(__rvm_rvmrc_key "$1")" "0;$(__rvm_checksum_for_contents "$1")" > /dev/null 2>&1 || return $?
}
__rvm_use () 
{ 
    \typeset binary full_binary_path rvm_ruby_gem_home __path_prefix __path_suffix;
    __rvm_select "$@" || return $?;
    if [[ "system" == ${rvm_ruby_interpreter:="system"} ]]; then
        __rvm_use_system;
    else
        __rvm_use_ || return $?;
    fi;
    __rvm_use_common
}
__rvm_use_ () 
{ 
    rvm_ruby_home="${rvm_ruby_home%%@*}";
    if [[ ! -d "$rvm_ruby_home" ]]; then
        if [[ ${rvm_install_on_use_flag:-0} -eq 1 ]]; then
            rvm_warn "Required $rvm_ruby_string is not installed - installing.";
            __rvm_run_wrapper manage "install" "$rvm_ruby_string";
        else
            rvm_error "Required $rvm_ruby_string is not installed.";
            rvm_log "To install do: 'rvm install \"$rvm_ruby_string\"'";
            export rvm_recommended_ruby="rvm install $rvm_ruby_string";
            return 1;
        fi;
    fi;
    __rvm_gemset_use_ensure || return $?;
    export GEM_HOME GEM_PATH MY_RUBY_HOME RUBY_VERSION IRBRC;
    GEM_HOME="$rvm_ruby_gem_home";
    GEM_PATH="$rvm_ruby_gem_path";
    MY_RUBY_HOME="$rvm_ruby_home";
    RUBY_VERSION="$rvm_ruby_string";
    IRBRC="$rvm_ruby_irbrc";
    unset BUNDLE_PATH;
    if [[ "maglev" == "$rvm_ruby_interpreter" ]]; then
        GEM_PATH="$GEM_PATH:$MAGLEV_HOME/lib/maglev/gems/1.8/";
    fi;
    [[ -n "${IRBRC:-}" ]] || unset IRBRC;
    if (( ${rvm_use_flag:-1} >= 2 && ${rvm_internal_use_flag:-0} == 0 )) || (( ${rvm_use_flag:-1} == 1 && ${rvm_verbose_flag:-0} == 1 )); then
        rvm_log "Using ${GEM_HOME/${rvm_gemset_separator:-'@'}/ with gemset }";
    fi;
    if [[ "$GEM_HOME" != "$rvm_ruby_global_gems_path" ]]; then
        __path_prefix="$GEM_HOME/bin:$rvm_ruby_global_gems_path/bin:${rvm_ruby_binary%/*}:${rvm_bin_path}";
    else
        __path_prefix="$GEM_HOME/bin:${rvm_ruby_binary%/*}:${rvm_bin_path}";
    fi;
    __path_suffix=""
}
__rvm_use_common () 
{ 
    [[ -z "${rvm_ruby_string:-}" ]] || export rvm_ruby_string;
    [[ -z "${rvm_gemset_name:-}" ]] || export rvm_gemset_name;
    \typeset __save_PATH;
    __rvm_remove_rvm_from_path;
    __save_PATH=$PATH;
    if [[ -n "${_OLD_VIRTUAL_PATH}" ]]; then
        PATH="${_OLD_VIRTUAL_PATH}";
        __rvm_remove_rvm_from_path;
        _OLD_VIRTUAL_PATH="${__path_prefix:-}${__path_prefix:+:}${PATH}${__path_suffix:+:}${__path_suffix:-}";
    fi;
    PATH="${__path_prefix:-}${__path_prefix:+:}$__save_PATH${__path_suffix:+:}${__path_suffix:-}";
    export PATH;
    builtin hash -r;
    if [[ "$rvm_ruby_string" != "system" ]]; then
        case "${rvm_rvmrc_flag:-0}" in 
            rvmrc | versions_conf | ruby_version)
                __rvm_set_${rvm_rvmrc_flag}
            ;;
        esac;
        \typeset environment_id;
        environment_id="$(__rvm_env_string)";
        if (( ${rvm_default_flag:=0} == 1 )) && [[ "default" != "${rvm_ruby_interpreter:-}" ]] && [[ "system" != "${rvm_ruby_interpreter:-}" ]]; then
            "$rvm_scripts_path/alias" delete default >&/dev/null;
            "$rvm_scripts_path/alias" create default "$environment_id" >&/dev/null;
        fi;
        rvm_default_flag=0;
        if [[ -n "${rvm_ruby_alias:-}" ]]; then
            rvm_log "Attempting to alias $environment_id to $rvm_ruby_alias";
            "$rvm_scripts_path/alias" delete "$rvm_ruby_alias" > /dev/null 2>&1;
            rvm_alias_expanded=1 "$rvm_scripts_path/alias" create "$rvm_ruby_alias" "$environment_id" > /dev/null 2>&1;
            ruby_alias="";
            rvm_ruby_alias="";
        fi;
    else
        if (( ${rvm_default_flag:=0} == 1 )); then
            builtin command -v __rvm_reset >> /dev/null 2>&1 || source "$rvm_scripts_path/functions/reset";
            __rvm_reset;
        fi;
    fi;
    rvm_hook="after_use";
    source "$rvm_scripts_path/hook";
    return 0
}
__rvm_use_ruby_warnings () 
{ 
    if [[ "${rvm_ruby_string}" == "system" || "${rvm_ruby_string}" == "" ]]; then
        return 0;
    fi;
    \typeset __executable __gem_version;
    for __executable in ruby gem irb;
    do
        [[ -x "$MY_RUBY_HOME/bin/${__executable}" ]] || rvm_warn "Warning! Executable '${__executable}' missing, something went wrong with this ruby installation!";
    done;
    if [[ "${rvm_ruby_interpreter}" == "ruby" ]] && { 
        __rvm_version_compare "${rvm_ruby_version}" -ge 2.0.0 || [[ "${rvm_ruby_version}" == "head" ]]
    } && __rvm_which gem > /dev/null && __gem_version="$(RUBYGEMS_GEMDEPS= gem --version)" && [[ -n "${__gem_version}" ]] && __rvm_version_compare "${__gem_version}" -lt "2.0.0"; then
        rvm_warn "Warning! You have just used ruby 2.0.0 or newer, which is not fully compatible with rubygems 1.8.x or older,
         consider upgrading rubygems with: 'rvm rubygems latest'.";
    fi
}
__rvm_use_system () 
{ 
    unset GEM_HOME GEM_PATH MY_RUBY_HOME RUBY_VERSION IRBRC;
    if [[ -s "$rvm_path/config/system" ]]; then
        if __rvm_grep "MY_RUBY_HOME='$rvm_rubies_path" "$rvm_path/config/system" > /dev/null; then
            if [[ -f "$rvm_path/config/system" ]]; then
                \command \rm -f "$rvm_path/config/system";
            fi;
        else
            source "$rvm_path/config/system";
        fi;
    fi;
    if (( ${rvm_default_flag:=0} == 1 )); then
        "$rvm_scripts_path/alias" delete default >&/dev/null;
        __rvm_find "${rvm_bin_path}" -maxdepth 0 -name 'default_*' -exec rm '{}' \;;
        \command \rm -f "$rvm_path/config/default";
        \command \rm -f "$rvm_environments_path/default";
        __rvm_rm_rf "$rvm_wrappers_path/default";
    fi;
    rvm_verbose_log "Now using system ruby.";
    __path_prefix="";
    __path_suffix="${rvm_bin_path}";
    export rvm_ruby_string="system"
}
__rvm_using_gemset_globalcache () 
{ 
    __rvm_db_ "$rvm_user_path/db" "use_gemset_globalcache" | __rvm_grep '^true$' > /dev/null 2>&1;
    return $?
}
__rvm_version () 
{ 
    echo "rvm $(__rvm_version_installed) by $(__rvm_version_authors) [$(__rvm_version_website)]"
}
__rvm_version_authors () 
{ 
    echo "Michal Papis, Piotr Kuczynski, Wayne E. Seguin"
}
__rvm_version_compare () 
{ 
    \typeset first;
    first="$( \command \printf "%b" "$1\n$3\n" | __rvm_version_sort | \command \head -n1 )";
    case "$2" in 
        -eq | == | =)
            [[ "$1" == "$3" ]] || return $?
        ;;
        -ne | !=)
            [[ "$1" != "$3" ]] || return $?
        ;;
        -gt | \>)
            if [[ "$first" == "head" ]]; then
                [[ "$first" == "$1" && "$1" != "$3" ]] || return $?;
            else
                [[ "$first" == "$3" && "$1" != "$3" ]] || return $?;
            fi
        ;;
        -ge | \>=)
            if [[ "$first" == "head" ]]; then
                [[ "$first" == "$1" || "$1" == "$3" ]] || return $?;
            else
                [[ "$first" == "$3" || "$1" == "$3" ]] || return $?;
            fi
        ;;
        -lt | \<)
            if [[ "$first" == "head" ]]; then
                [[ "$first" == "$3" && "$1" != "$3" ]] || return $?;
            else
                [[ "$first" == "$1" && "$1" != "$3" ]] || return $?;
            fi
        ;;
        -le | \<=)
            if [[ "$first" == "head" ]]; then
                [[ "$first" == "$3" || "$1" == "$3" ]] || return $?;
            else
                [[ "$first" == "$1" || "$1" == "$3" ]] || return $?;
            fi
        ;;
        *)
            rvm_error "Unsupported operator '$2'.";
            return 1
        ;;
    esac;
    return 0
}
__rvm_version_copyright () 
{ 
    echo "(c) 2009-2017 $(__rvm_version_authors)"
}
__rvm_version_installed () 
{ 
    echo "$(\command \cat "$rvm_path/VERSION") ($(\command \cat "$rvm_path/RELEASE" 2>/dev/null))"
}
__rvm_version_remote () 
{ 
    __rvm_curl -s --max-time 10 https://github.com/rvm/rvm/raw/master/VERSION || true
}
__rvm_version_sort () 
{ 
    \command \awk -F'[.-]' -v OFS=. '{       # split on "." and "-", merge back with "."
    original=$0                            # save original to preserve it before the line is changed
    for (n=1; n<10; n++) {                 # iterate through max 9 components of version
      $n=tolower($n)                       # ignore case for sorting
      if ($n=="")         $n="0"           # treat non existing parts as 0
      if ($n ~ /^p[0-9]/) $n=substr($n, 2) # old ruby -p notation
      if ($n ~ /^[a-z]/)  $n=" "$n         # names go before numbers thanks to space
    }
    print $0"\t"original                   # print the transformed version and original separated by \t so we can extract original after sorting
  }' | LC_ALL=C \sort -t. -k 1,1d -k 2,2n -k 3,3n -k 4,4n -k 5,5n -k 6,6n -k 7,7n -k 8,8n -k 9,9n | \awk -F'\t' '{print $2}'
}
__rvm_version_website () 
{ 
    echo "https://rvm.io"
}
__rvm_wait_anykey () 
{ 
    if [[ -n "${1:-}" ]]; then
        echo "$1";
    fi;
    \typeset _read_char_flag;
    if [[ -n "${ZSH_VERSION:-}" ]]; then
        _read_char_flag=k;
    else
        _read_char_flag=n;
    fi;
    builtin read -${_read_char_flag} 1 -s -r anykey
}
__rvm_which () 
{ 
    \command \which "$@" || return $?
}
__rvm_with () 
{ 
    ( unset rvm_rvmrc_flag;
    export rvm_create_flag=1;
    export rvm_delete_flag=0;
    export rvm_internal_use_flag=1;
    export rvm_use_flag=0;
    __rvm_use "$1" || return $?;
    shift;
    "$@" || return $? )
}
__rvm_xargs () 
{ 
    \xargs "$@" || return $?
}
__rvmrc_full_path_to_file () 
{ 
    if [[ "$1" == "all.rvmrcs" || "$1" == "allGemfiles" ]]; then
        __rvmrc_warning_file="$1";
    else
        if [[ -d "$1" && -s "$1/.rvmrc" ]]; then
            __rvmrc_warning_file="$( __rvm_cd "$1" >/dev/null 2>&1; pwd )/.rvmrc";
        else
            if [[ -d "$1" && -s "$1/Gemfile" ]]; then
                __rvmrc_warning_file="$( __rvm_cd "$1" >/dev/null 2>&1; pwd )/Gemfile";
            else
                if [[ -f "$1" || "$1" == *".rvmrc" || "$1" == *"Gemfile" ]]; then
                    __rvmrc_warning_file="$( dirname "$1" )";
                    : __rvmrc_warning_file:${__rvmrc_warning_file:=$PWD};
                    __rvmrc_warning_file="${__rvmrc_warning_file}/${1##*/}";
                else
                    rvm_warn "Do not know how to handle '$1', please report: https://bit.ly/rvm-issues ~ __rvmrc_full_path_to_file";
                    return 1;
                fi;
            fi;
        fi;
    fi
}
__rvmrc_warning () 
{ 
    \typeset __rvmrc_warning_path __rvmrc_warning_file;
    __rvmrc_warning_path="$rvm_user_path/rvmrc_ignored";
    case "${1:-help}" in 
        list)
            __rvmrc_warning_$1 "${2:-}" || return $?
        ;;
        check | check_quiet | ignore | reset)
            __rvmrc_full_path_to_file "${2:-}" && __rvmrc_warning_$1 "${__rvmrc_warning_file:-${2:-}}" || return $?
        ;;
        help)
            rvm_help rvmrc warning
        ;;
        *)
            rvm_error_help "Unknown subcommand '$1'" rvmrc warning;
            return 1
        ;;
    esac
}
__rvmrc_warning_check () 
{ 
    if __rvmrc_warning_check_quiet "$1"; then
        rvm_log "path '$1' is ignored.";
    else
        \typeset ret=$?;
        rvm_log "path '$1' is not ignored.";
        return $ret;
    fi
}
__rvmrc_warning_check_quiet () 
{ 
    [[ -f "$__rvmrc_warning_path" ]] || return $?;
    \typeset __rvmrc_type;
    case "$1" in 
        all.rvmrcs | allGemfiles)
            true
        ;;
        *)
            __rvmrc_type="^all${1##*/}s";
            if __rvm_grep "${__rvmrc_type}$" "$__rvmrc_warning_path" > /dev/null; then
                return 0;
            fi
        ;;
    esac;
    __rvm_grep "^$1$" "$__rvmrc_warning_path" > /dev/null || return $?
}
__rvmrc_warning_display_for_Gemfile () 
{ 
    \typeset __rvmrc_warning_path __rvmrc_warning_file;
    __rvmrc_warning_path="$rvm_user_path/rvmrc_ignored";
    if [[ -t 2 ]] && __rvmrc_full_path_to_file "${1:-}" && ! __rvmrc_warning_check_quiet "${__rvmrc_warning_file:-${2:-}}"; then
        rvm_warn "RVM used your Gemfile for selecting Ruby, it is all fine - Heroku does that too,
you can ignore these warnings with 'rvm rvmrc warning ignore $1'.
To ignore the warning for all files run 'rvm rvmrc warning ignore allGemfiles'.
";
    fi
}
__rvmrc_warning_display_for_rvmrc () 
{ 
    \typeset __rvmrc_warning_path __rvmrc_warning_file;
    __rvmrc_warning_path="$rvm_user_path/rvmrc_ignored";
    if [[ -t 2 ]] && __rvmrc_full_path_to_file "${1:-}" && ! __rvmrc_warning_check_quiet "${__rvmrc_warning_file:-${2:-}}"; then
        rvm_warn "You are using '.rvmrc', it requires trusting, it is slower and it is not compatible with other ruby managers,
you can switch to '.ruby-version' using 'rvm rvmrc to ruby-version'
or ignore this warning with 'rvm rvmrc warning ignore $1',
'.rvmrc' will continue to be the default project file in RVM 1 and RVM 2,
to ignore the warning for all files run 'rvm rvmrc warning ignore all.rvmrcs'.
";
    fi
}
__rvmrc_warning_ignore () 
{ 
    __rvmrc_warning_check_quiet "$1" || case "$1" in 
        all.rvmrcs | allGemfiles)
            echo "$1" >> "$__rvmrc_warning_path"
        ;;
        *)
            echo "$1" >> "$__rvmrc_warning_path"
        ;;
    esac
}
__rvmrc_warning_list () 
{ 
    rvm_log "# List of project files that ignore warnings:";
    if [[ -s "$__rvmrc_warning_path" ]]; then
        \command \cat "$__rvmrc_warning_path";
    fi
}
__rvmrc_warning_reset () 
{ 
    \typeset __rvmrc_type;
    case "${1:-}" in 
        all.rvmrcs | allGemfiles)
            if __rvmrc_warning_check_quiet "$1"; then
                __rvm_sed_i "$__rvmrc_warning_path" -e "\#^${1}\$# d" -e '/^$/ d';
                __rvmrc_type="${1#all}";
                __rvmrc_type="${__rvmrc_type%s}";
                __rvm_sed_i "$__rvmrc_warning_path" -e "\#/${__rvmrc_type}\$# d" -e '\#^$# d';
            else
                rvm_debug "Already removed warning ignore from '$1'.";
            fi
        ;;
        *)
            if __rvmrc_warning_check_quiet "$1"; then
                __rvm_sed_i "$__rvmrc_warning_path" -e "\#^${1}\$# d" -e '\#^$# d';
            else
                rvm_debug "Already removed warning ignore from '$1'.";
            fi
        ;;
    esac
}
__setup_lang_fallback () 
{ 
    if [[ -z "${LANG:-}" ]]; then
        LANG="$(
      {
        locale -a | __rvm_grep "^en_US.utf8" ||
        locale -a | __rvm_grep "^en_US" ||
        locale -a | __rvm_grep "^en" ||
        locale -a
      } 2>/dev/null | \command \head -n 1
    )";
        : LANG=${LANG:=en_US.utf-8};
        export LANG;
        rvm_warn "\$LANG was empty, setting up LANG=$LANG, if it fails again try setting LANG to something sane and try again.";
    fi
}
__variables_definition () 
{ 
    \typeset -a __variables_list __array_list;
    \typeset __method;
    __method="$1";
    __variables_list=(rvm_head_flag rvm_ruby_selected_flag rvm_user_install_flag rvm_path_flag rvm_cron_flag rvm_static_flag rvm_default_flag rvm_loaded_flag rvm_llvm_flag rvm_skip_autoreconf_flag rvm_dynamic_extensions_flag rvm_18_flag rvm_19_flag rvm_20_flag rvm_21_flag rvm_force_autoconf_flag rvm_dump_environment_flag rvm_curl_flags rvm_rubygems_version rvm_verbose_flag rvm_debug_flag rvm_trace_flag __array_start rvm_skip_pristine_flag rvm_create_flag rvm_remove_flag rvm_movable_flag rvm_archive_flag rvm_gemdir_flag rvm_reload_flag rvm_auto_reload_flag rvm_disable_binary_flag rvm_ignore_gemsets_flag rvm_skip_gemsets_flag rvm_install_on_use_flag rvm_remote_flag rvm_verify_downloads_flag rvm_skip_openssl_flag rvm_gems_cache_path rvm_gems_path rvm_man_path rvm_ruby_gem_path rvm_ruby_log_path rvm_gems_cache_path rvm_archives_path rvm_docs_path rvm_environments_path rvm_examples_path rvm_gems_path rvm_gemsets_path rvm_help_path rvm_hooks_path rvm_lib_path rvm_log_path rvm_patches_path rvm_repos_path rvm_rubies_path rvm_scripts_path rvm_src_path rvm_tmp_path rvm_user_path rvm_usr_path rvm_wrappers_path rvm_stored_errexit rvm_ruby_strings rvm_ruby_binary rvm_ruby_gem_home rvm_ruby_home rvm_ruby_interpreter rvm_ruby_irbrc rvm_ruby_major_version rvm_ruby_minor_version rvm_ruby_package_name rvm_ruby_patch_level rvm_ruby_release_version rvm_ruby_repo_url rvm_ruby_repo_branch rvm_ruby_revision rvm_ruby_tag rvm_ruby_sha rvm_ruby_version rvm_ruby_package_file rvm_ruby_name rvm_ruby_name rvm_ruby_args rvm_ruby_user_tag rvm_ruby_patch detected_rvm_ruby_name __rvm_env_loaded next_token rvm_error_message rvm_gemset_name rvm_parse_break rvm_token rvm_action rvm_export_args rvm_gemset_separator rvm_expanding_aliases rvm_tar_command rvm_tar_options rvm_patch_original_pwd rvm_project_rvmrc rvm_archive_extension rvm_autoinstall_bundler_flag rvm_codesign_identity rvm_expected_gemset_name rvm_without_gems rvm_with_gems rvm_with_default_gems rvm_ignore_dotfiles_flag rvm_fuzzy_flag rvm_autolibs_flag rvm_autolibs_flag_number rvm_autolibs_flag_runner rvm_quiet_curl_flag rvm_max_time_flag rvm_error_clr rvm_warn_clr rvm_debug_clr rvm_notify_clr rvm_reset_clr rvm_error_color rvm_warn_color rvm_debug_color rvm_notify_color rvm_reset_color rvm_log_timestamp rvm_log_filesystem rvm_log_namelen rvm_show_log_lines_on_error);
    __array_list=(rvm_patch_names rvm_ree_options rvm_autoconf_flags rvm_architectures);
    case "${__method}" in 
        export)
            true
        ;;
        unset)
            unset "${__array_list[@]}" || true
        ;;
        *)
            rvm_error "Unknown action given to __variables_definition: ${__method}";
            return 1
        ;;
    esac;
    ${__method} "${__variables_list[@]}" || true;
    if [[ -n "${BASH_VERSION:-}" ]]; then
        export -fn __rvm_select_version_variables __rvm_ruby_string_parse_ __rvm_rm_rf_verbose __rvm_parse_args 2> /dev/null || true;
    fi
}
__zsh_like_cd () 
{ 
    \typeset __zsh_like_cd_hook;
    if builtin "$@"; then
        for __zsh_like_cd_hook in chpwd "${chpwd_functions[@]}";
        do
            if \typeset -f "$__zsh_like_cd_hook" > /dev/null 2>&1; then
                "$__zsh_like_cd_hook" || break;
            fi;
        done;
        true;
    else
        return $?;
    fi
}
_bq_completer () 
{ 
    _completer "CLOUDSDK_COMPONENT_MANAGER_DISABLE_UPDATE_CHECK=1 bq help | grep '^[^ ][^ ]*  ' | sed 's/ .*//'" bq
}
_completer () 
{ 
    command=$1;
    name=$2;
    eval '[[ "$'"${name}"'_COMMANDS" ]] || '"${name}"'_COMMANDS="$('"${command}"')"';
    set -- $COMP_LINE;
    shift;
    while [[ $1 == -* ]]; do
        shift;
    done;
    [[ -n $2 ]] && return;
    grep -q "${name}\s*$" <<< $COMP_LINE && eval 'COMPREPLY=($'"${name}"'_COMMANDS)' && return;
    [[ "$COMP_LINE" == *" " ]] && return;
    [[ -n $1 ]] && eval 'COMPREPLY=($(echo "$'"${name}"'_COMMANDS" | grep ^'"$1"'))'
}
_python_argcomplete () 
{ 
    local IFS='';
    local prefix=;
    typeset -i n;
    (( lastw=${#COMP_WORDS[@]} -1));
    if [[ ${COMP_WORDS[lastw]} == --*=* ]]; then
        flag=${COMP_WORDS[lastw]%%=*};
        set -- "$1" "$2" '=';
    else
        if [[ $3 == '=' ]]; then
            flag=${COMP_WORDS[-3]};
        fi;
    fi;
    if [[ $3 == ssh && $2 == *@* ]]; then
        prefix=${2%@*}@;
        COMP_LINE=${COMP_LINE%$2}"${2#*@}";
    else
        if [[ $3 == '=' ]]; then
            prefix=$flag=$2;
            line=${COMP_LINE%$prefix};
            COMP_LINE=$line${prefix/=/ };
            prefix=;
        fi;
    fi;
    if [[ $2 == *,* ]]; then
        prefix=${2%,*},;
        set -- "$1" "${2#$prefix}" "$3";
        COMP_LINE==${COMP_LINE%$prefix*}$2;
    fi;
    if [[ ${COMP_LINE} == *= && ${COMP_WORDS[-2]} == --* ]]; then
        COMP_LINE=${COMP_LINE%=}' ';
    fi;
    COMPREPLY=($(IFS="$IFS"                   COMP_LINE="$COMP_LINE"                   COMP_POINT="$COMP_POINT"                   _ARGCOMPLETE_COMP_WORDBREAKS="$COMP_WORDBREAKS"                   _ARGCOMPLETE=1                   "$1" 8>&1 9>&2 1>/dev/null 2>/dev/null));
    if [[ $? != 0 ]]; then
        unset COMPREPLY;
        return;
    fi;
    if [[ $prefix != '' ]]; then
        for ((n=0; n < ${#COMPREPLY[@]}; n++))
        do
            COMPREPLY[$n]=$prefix${COMPREPLY[$n]};
        done;
    fi;
    for ((n=0; n < ${#COMPREPLY[@]}; n++))
    do
        match=${COMPREPLY[$n]%' '};
        if [[ $match != '' ]]; then
            COMPREPLY[$n]=${match//? /' '}' ';
        fi;
    done;
    if [[ ${#COMPREPLY[@]} == 1 && ${COMPREPLY[0]} == -* && ${COMPREPLY[0]} == *'= ' ]]; then
        COMPREPLY[0]=${COMPREPLY[0]%' '};
    fi
}
cd () 
{ 
    __zsh_like_cd cd "$@"
}
file_exists_at_url () 
{ 
    ( if [[ -n "${1:-}" ]]; then
        unset curl;
        file_exists_at_url_command "$1" --insecure || { 
            \typeset __ret=$?;
            case ${__ret} in 
                60)
                    file_exists_at_url_command "$1" || return $?;
                    return 0
                ;;
                *)
                    return ${__ret}
                ;;
            esac
        };
    else
        rvm_warn "Warning: URL was not passed to file_exists_at_url";
        return 1;
    fi )
}
file_exists_at_url_command () 
{ 
    __rvm_curl --silent --insecure --location --list-only --max-time ${rvm_max_time_flag:-5} --head "$@" 2>&1 | __rvm_grep -E 'HTTP/[0-9\.]+ 200 OK' > /dev/null 2>&1 || { 
        \typeset __ret=$?;
        case ${__ret} in 
            28)
                rvm_warn "RVM was not able to check existence of remote files with timeout of ${rvm_max_time_flag:-3} seconds
you can increase the timeout by setting it in ~/.rvmrc => rvm_max_time_flag=10"
            ;;
        esac;
        return ${__ret}
    }
}
gem () 
{ 
    \typeset result;
    ( \typeset rvmrc;
    rvm_rvmrc_files=("/etc/rvmrc" "$HOME/.rvmrc");
    if [[ -n "${rvm_prefix:-}" ]] && ! [[ "$HOME/.rvmrc" -ef "${rvm_prefix}/.rvmrc" ]]; then
        rvm_rvmrc_files+=("${rvm_prefix}/.rvmrc");
    fi;
    for rvmrc in "${rvm_rvmrc_files[@]}";
    do
        [[ -s "${rvmrc}" ]] && source "${rvmrc}" || true;
    done;
    unset rvm_rvmrc_files;
    command gem "$@" ) || result=$?;
    hash -r;
    return ${result:-0}
}
gem_install () 
{ 
    \typeset gem_name gem_version version_check;
    gem_version="";
    __rvm_parse_gems_args "$@";
    if [[ -z "${gem_version}" ]]; then
        __rvm_db "gem_${gem_name}_version" "gem_version";
    fi;
    if (( ${rvm_force_flag:-0} == 0 )) && is_gem_installed; then
        rvm_log "gem ${gem_name} ${gem_version:-} is already installed";
        return 0;
    else
        gem_install_force || return $?;
    fi;
    true
}
gem_install_force () 
{ 
    \typeset __available_gem;
    \typeset -a install_params;
    install_params=();
    __available_gem="$( ls -v1 "${rvm_path}/gem-cache"/${gem_name}-${version_check}.gem 2>/dev/null | tail -n 1 )";
    if [[ -n "${__available_gem}" ]]; then
        install_params+=(--local);
    else
        if [[ -n "${gem_version}" ]]; then
            install_params+=(-v "${gem_version}");
        fi;
    fi;
    install_params+=(--no-ri --no-rdoc $rvm_gem_options);
    __rvm_log_command "gem.install.${gem_name}${gem_version:+-}${gem_version:-}" "installing gem ${__available_gem:-${gem_name}} ${install_params[*]}" \command \gem install "${__available_gem:-${gem_name}}" "${install_params[@]}" || return $?
}
gemset_create () 
{ 
    \typeset gem_home gemset gemsets prefix;
    [[ -n "$rvm_ruby_string" ]] || __rvm_select;
    prefix="${rvm_ruby_gem_home%%${rvm_gemset_separator:-"@"}*}";
    for gemset in "$@";
    do
        if [[ -z "$rvm_ruby_string" || "$rvm_ruby_string" == "system" ]]; then
            rvm_error "Can not create gemset when using system ruby.  Try 'rvm use <some ruby>' first.";
            return 1;
        else
            if [[ "$gemset" == *"${rvm_gemset_separator:-"@"}"* ]]; then
                rvm_error "Can not create gemset '$gemset', it contains a \"${rvm_gemset_separator:-"@"}\".";
                return 2;
            else
                if [[ "$gemset" == *"${rvm_gemset_separator:-"@"}" ]]; then
                    rvm_error "Can not create gemset '$gemset', Missing name. ";
                    return 3;
                fi;
            fi;
        fi;
        gem_home="${prefix}${gemset:+${rvm_gemset_separator:-"@"}}${gemset}";
        __rvm_remove_broken_symlinks "$gem_home";
        [[ -d "$gem_home/bin" ]] || mkdir -p "$gem_home/bin";
        if [[ ! -d "$gem_home/bin" ]]; then
            rvm_error "Can not create gemset '$gemset', permissions problem? ";
            return 4;
        fi;
        : rvm_gems_cache_path:${rvm_gems_cache_path:=${rvm_gems_path:-"$rvm_path/gems"}/cache};
        if __rvm_using_gemset_globalcache; then
            if [[ -d "$gem_home/cache" && ! -L "$gem_home/cache" ]]; then
                \command \mv "$gem_home/cache"/*.gem "$rvm_gems_cache_path/" 2> /dev/null;
            fi;
            __rvm_rm_rf "$gem_home/cache";
            ln -fs "$rvm_gems_cache_path" "$gem_home/cache";
        else
            __rvm_remove_broken_symlinks "$gem_home/cache";
            mkdir -p "$gem_home/cache";
        fi;
        rvm_log "$rvm_ruby_string - #gemset created $gem_home";
        if (( ${rvm_skip_gemsets_flag:-0} == 0 )); then
            __rvm_with "${rvm_ruby_string}${gemset:+@}${gemset}" gemset_initial ${gemset:-default};
        fi;
    done;
    if (( ${rvm_skip_gemsets_flag:-0} != 0 )); then
        rvm_log "Skipped importing default gemsets";
    fi
}
gemset_import () 
{ 
    \typeset __prefix rvm_file_name;
    unset -f gem;
    __rvm_select;
    __prefix="$1";
    if [[ -n "${2:-}" ]]; then
        rvm_file_name="${2%.gems*}.gems";
    else
        \typeset -a gem_file_names;
        gem_file_names=("${rvm_gemset_name}.gems" "default.gems" "system.gems" ".gems");
        __rvm_find_first_file rvm_file_name "${gem_file_names[@]}" || { 
            rvm_error "No *.gems file found.";
            return 1
        };
    fi;
    [[ -d "$rvm_ruby_gem_home/specifications/" ]] || mkdir -p "$rvm_ruby_gem_home/specifications/";
    [[ -d "$rvm_gems_cache_path" ]] || mkdir -p "$rvm_gems_cache_path";
    \typeset -a lines;
    lines=();
    if [[ -s "$rvm_file_name" ]]; then
        __rvm_read_lines lines "${rvm_file_name}";
        __rvm_lines_without_comments;
    fi;
    rvm_debug "lines from ${rvm_file_name}: ${lines[*]}";
    if [[ -n "${3:-}" ]]; then
        __rvm_lines_without_gems;
        __rvm_lines_with_gems "${3}";
        rvm_debug "recalculated lines($3): ${lines[*]}";
    fi;
    if (( ${#lines[@]} )); then
        __rvm_log_command "gemsets.import${3:+.}${3:-}" "${__prefix} $rvm_file_name" gemset_import_list "${lines[@]}";
    else
        rvm_log "${__prefix}file $rvm_file_name evaluated to empty gem list";
    fi
}
gemset_import_list () 
{ 
    case "${rvm_ruby_string}" in 
        *jruby*)
            \command \gem install "$@"
        ;;
        *)
            \typeset line;
            for line in "$@";
            do
                gem_install $line || rvm_error "there was an error installing gem $line";
            done
        ;;
    esac
}
gemset_initial () 
{ 
    \typeset gemsets gemset _iterator paths;
    true ${rvm_gemsets_path:="$rvm_path/gemsets"};
    [[ -d "$rvm_gems_path/${rvm_ruby_string}/cache" ]] || mkdir -p "$rvm_gems_path/${rvm_ruby_string}/cache" 2> /dev/null;
    __rvm_ensure_has_environment_files;
    paths=($( __rvm_ruby_string_paths_under "$rvm_gemsets_path" | sort -r ));
    for _iterator in "${paths[@]}";
    do
        if [[ -f "${_iterator}/$1.gems" ]]; then
            gemset_import "$rvm_ruby_string - #importing gemset" "${_iterator}/$1.gems" "$1";
            break;
        else
            rvm_debug "$rvm_ruby_string - #gemset definition does not exist ${_iterator}/$1.gems";
        fi;
    done;
    __rvm_log_command "gemset.wrappers.$1" "$rvm_ruby_string - #generating ${1} wrappers" run_gem_wrappers_regenerate 2> /dev/null || true
}
gemset_pristine () 
{ 
    if ( unset -f gem;
    builtin command -v gem > /dev/null ); then
        \typeset _gem _version _platforms;
        \typeset -a _failed _pristine_command;
        _failed=();
        _pristine_command=(\command \gem pristine);
        if __rvm_version_compare "$(\command \gem --version)" -ge 2.2.0; then
            _pristine_command+=(--extensions);
        fi;
        rvm_log "Restoring gems to pristine condition...";
        while read _gem _version _platforms; do
            printf "%b" "${_gem}-${_version} ";
            "${_pristine_command[@]}" "${_gem}" --version "${_version}" > /dev/null || _failed+=("${_gem} --version ${_version}");
        done <<< $'"$(\n      GEM_PATH="$GEM_HOME" __rvm_list_gems         "${pristine_gems_filter:-"! gem.executables.empty? || ! gem.extensions.empty?"}"\n    )"';
        if (( ${#_failed[@]} > 0 )); then
            rvm_error "\n'${_pristine_command[*]} ${_failed[*]}' failed, you need to fix this gems manually.";
            return 1;
        else
            rvm_log "\nfinished.";
        fi;
    else
        rvm_error "'gem' command not found in PATH.";
        return 1;
    fi
}
gemset_reset_env () 
{ 
    ( export rvm_internal_use_flag=1;
    export rvm_use_flag=0;
    __rvm_use "${1:-}";
    __rvm_ensure_has_environment_files && run_gem_wrappers_regenerate )
}
is_a_function () 
{ 
    \typeset -f $1 > /dev/null 2>&1 || return $?
}
is_gem_installed () 
{ 
    \typeset gem_spec;
    gem_spec="gem '$gem_name'";
    if [[ -n "${gem_version}" ]]; then
        gem_spec+=", '$gem_version'";
        version_check="${gem_version#*=}";
    else
        version_check="*([[:digit:]\.])";
    fi;
    ls -ld "${rvm_ruby_gem_home}/gems"/${gem_name}-${version_check} > /dev/null 2>&1 || "${rvm_ruby_binary}" -rrubygems -e "$gem_spec" 2> /dev/null || return $?
}
is_parent_of () 
{ 
    \typeset name pid ppid pname;
    name=$1;
    pid=$2;
    while [[ -n "$pid" && "$pid" != "0" ]]; do
        case "`uname`" in 
            SunOS)
                read ppid pname <<< "$(\command \ps -p $pid -o ppid= -o comm=)"
            ;;
            *)
                read ppid pname <<< "$(\command \ps -p $pid -o ppid= -o ucomm=)"
            ;;
        esac;
        if [[ -n "$ppid" && -n "$pname" ]]; then
            if [[ "$pname" == "$name" ]]; then
                echo $pid;
                return 0;
            else
                pid=$ppid;
            fi;
        else
            break;
        fi;
    done;
    return 1
}
load_rvm_scripts () 
{ 
    \typeset -a scripts;
    scripts=(selector logging support utility init cleanup env rvmrc install environment gemset checksum list);
    source "${rvm_scripts_path}/initialize";
    for entry in ${scripts[@]};
    do
        [[ " ${rvm_base_except:-} " == *" $entry "* ]] || source "${rvm_scripts_path}/functions/$entry" || return $?;
    done;
    unset rvm_base_except
}
popd () 
{ 
    __zsh_like_cd popd "$@"
}
pushd () 
{ 
    __zsh_like_cd pushd "$@"
}
rubygems_detect_ruby_lib_gem_path () 
{ 
    \typeset ruby_path;
    ruby_path="$( __rvm_which "${1:-ruby}" )" || { 
        rvm_error "Missing 'ruby' in 'rubygems_detect_ruby_lib_gem_path'.";
        return 1
    };
    ruby_lib_gem_path="$(
    unset GEM_HOME GEM_PATH
    "$ruby_path" -rrubygems -e 'puts Gem.default_dir' 2>/dev/null
  )" || ruby_lib_gem_path="";
    [[ -n "$ruby_lib_gem_path" ]] || rubygems_detect_ruby_lib_gem_path_fallback || return $?
}
rubygems_detect_ruby_lib_gem_path_fallback () 
{ 
    rubygems_detect_ruby_lib_gem_path_from "rubylib" || rubygems_detect_ruby_lib_gem_path_from "lib" || return $?;
    ruby_lib_gem_path+="/gems";
    \typeset ruby_version;
    ruby_version="$( __rvm_ruby_config_get ruby_version "$ruby_path")" || ruby_version="";
    if [[ -n "${ruby_version:-}" && -d "${ruby_lib_gem_path}/${ruby_version:-}" ]]; then
        ruby_lib_gem_path+="$ruby_version";
    else
        if [[ -d "${ruby_lib_gem_path}/shared" ]]; then
            ruby_lib_gem_path+="shared";
        else
            return 3;
        fi;
    fi
}
rubygems_detect_ruby_lib_gem_path_from () 
{ 
    ruby_lib_gem_path="$( __rvm_ruby_config_get ${1}prefix "$ruby_path" )" || ruby_lib_gem_path="";
    [[ -z "${ruby_lib_gem_path:-}" ]] || { 
        ruby_lib_gem_path="$( __rvm_ruby_config_get ${1}dir  "$ruby_path" )" || ruby_lib_gem_path="";
        ruby_lib_gem_path="${ruby_lib_gem_path%/*}"
    };
    [[ -n "${ruby_lib_gem_path:-}" ]] || return 1;
    [[ -d "${ruby_lib_gem_path}/gems" ]] || return 2
}
run_gem_wrappers_regenerate () 
{ 
    gem_install gem-wrappers && gem wrappers regenerate || return $?
}
rvm () 
{ 
    \typeset result current_result;
    rvm_ruby_args=();
    __rvm_teardown_if_broken;
    __rvm_cli_posix_check || return $?;
    __rvm_cli_load_rvmrc || return $?;
    __rvm_cli_version_check "$@" || return $?;
    __rvm_path_match_gem_home_check;
    __rvm_initialize;
    __rvm_setup;
    __rvm_cli_autoupdate "$@" || return $?;
    next_token="$1";
    (( $# == 0 )) || shift;
    __rvm_parse_args "$@";
    result=$?;
    : rvm_ruby_args:${#rvm_ruby_args[@]}:${rvm_ruby_args[*]}:;
    (( ${rvm_trace_flag:-0} == 0 )) || set -o xtrace;
    (( result )) || case "${rvm_action:=help}" in 
        use)
            if rvm_is_a_shell_function; then
                __rvm_use && __rvm_use_ruby_warnings;
            fi
        ;;
        switch)
            if rvm_is_a_shell_function; then
                __rvm_switch "${rvm_ruby_args[@]}";
            fi
        ;;
        inspect | strings | version | remote_version)
            __rvm_${rvm_action}
        ;;
        ls | list)
            "$rvm_scripts_path/list" "${rvm_ruby_args[@]}"
        ;;
        debug)
            rvm_is_not_a_shell_function="${rvm_is_not_a_shell_function}" "$rvm_scripts_path/info" '' debug
        ;;
        info)
            rvm_is_not_a_shell_function="${rvm_is_not_a_shell_function}" "$rvm_scripts_path/${rvm_action}" "${rvm_ruby_args[@]}"
        ;;
        reset)
            source "$rvm_scripts_path/functions/${rvm_action}";
            __rvm_${rvm_action}
        ;;
        update)
            printf "%b" "ERROR: rvm update has been removed. Try 'rvm get head' or see the 'rvm get' and rvm 'rubygems' CLI API instead\n"
        ;;
        implode | seppuku)
            source "$rvm_scripts_path/functions/implode";
            __rvm_implode
        ;;
        get)
            next_token="${1:-}";
            (( $# == 0 )) || shift;
            [[ "$next_token" == "${rvm_action}" ]] && shift;
            __rvm_cli_rvm_get "${rvm_ruby_args[@]}"
        ;;
        current)
            __rvm_env_string
        ;;
        help | rtfm | env | list | monitor | notes | pkg | requirements)
            next_token="${1:-}";
            (( $# == 0 )) || shift;
            if (( $# )) && [[ "$next_token" == "${rvm_action}" ]]; then
                shift;
            fi;
            "$rvm_scripts_path/${rvm_action}" "${rvm_ruby_args[@]}"
        ;;
        cleanup | tools | snapshot | disk-usage | repair | alias | docs | rubygems | migrate | cron | group)
            "$rvm_scripts_path/${rvm_action}" "${rvm_ruby_args[@]}"
        ;;
        upgrade)
            __rvm_fix_selected_ruby __rvm_run_wrapper "$rvm_action" "$rvm_action" "${rvm_ruby_args[@]}"
        ;;
        autolibs | osx-ssl-certs | fix-permissions)
            __rvm_run_wrapper "$rvm_action" "$rvm_action" "${rvm_ruby_args[@]}"
        ;;
        wrapper)
            "$rvm_scripts_path/wrapper" "$rvm_ruby_string" "$rvm_wrapper_name" "${rvm_ruby_args[@]}";
            result=$?;
            unset rvm_wrapper_name
        ;;
        do)
            old_rvm_ruby_string=${rvm_ruby_string:-};
            unset rvm_ruby_string;
            export rvm_ruby_strings rvm_in_flag;
            result=0;
            if rvm_is_a_shell_function no_warning; then
                "$rvm_scripts_path/set" "$rvm_action" "${rvm_ruby_args[@]}" || result=$?;
            else
                exec "$rvm_scripts_path/set" "$rvm_action" "${rvm_ruby_args[@]}" || result=$?;
            fi;
            [[ -n "$old_rvm_ruby_string" ]] && rvm_ruby_string=$old_rvm_ruby_string;
            unset old_rvm_ruby_string
        ;;
        rvmrc)
            __rvm_rvmrc_tools "${rvm_ruby_args[@]}"
        ;;
        config-get)
            \typeset __ruby __var;
            __ruby=$( __rvm_which ruby );
            for __var in "${rvm_ruby_args[@]}";
            do
                __rvm_ruby_config_get "${__var}" "${__ruby}";
            done
        ;;
        gemset_use)
            if rvm_is_a_shell_function; then
                __rvm_gemset_use;
            fi
        ;;
        gemset)
            export rvm_ruby_strings;
            "$rvm_scripts_path/gemsets" "${rvm_ruby_args[@]}";
            result=$?;
            rvm_ruby_strings="";
            if rvm_is_a_shell_function no_warning; then
                if [[ ${rvm_delete_flag:-0} -eq 1 ]]; then
                    if [[ "${GEM_HOME:-""}" == "${GEM_HOME%%${rvm_gemset_separator:-@}*}${rvm_gemset_separator:-@}${rvm_gemset_name}" ]]; then
                        rvm_delete_flag=0;
                        __rvm_use "@default";
                    fi;
                    unset gem_prefix;
                else
                    if [[ "${rvm_ruby_args[*]}" == rename* ]]; then
                        \typeset _command _from _to;
                        read _command _from _to <<< "${rvm_ruby_args[*]}";
                        if [[ "${GEM_HOME:-""}" == "${GEM_HOME%%${rvm_gemset_separator:-@}*}${rvm_gemset_separator:-@}${_from}" ]]; then
                            __rvm_use "@${_to}";
                        fi;
                    fi;
                fi;
            fi
        ;;
        reload)
            rvm_reload_flag=1
        ;;
        tests | specs)
            rvm_action="rake";
            __rvm_do
        ;;
        remove)
            export rvm_path;
            if [[ -n "${rvm_ruby_strings}" ]]; then
                __rvm_run_wrapper manage "$rvm_action" "${rvm_ruby_strings//*-- }";
            else
                __rvm_run_wrapper manage "$rvm_action";
            fi;
            __rvm_use default
        ;;
        fetch | uninstall | reinstall)
            export rvm_path;
            if [[ -n "${rvm_ruby_strings}" ]]; then
                __rvm_run_wrapper manage "$rvm_action" "${rvm_ruby_strings//*-- }";
            else
                __rvm_run_wrapper manage "$rvm_action";
            fi
        ;;
        try_install | install)
            export rvm_path;
            __rvm_cli_install_ruby "${rvm_ruby_strings}"
        ;;
        automount)
            if [[ -n "$rvm_ruby_string" ]]; then
                rvm_ruby_args=("$rvm_ruby_string" "${rvm_ruby_args[@]}");
            fi;
            "${rvm_scripts_path}/mount" "$rvm_action" "${rvm_ruby_args[@]}"
        ;;
        mount | prepare)
            if [[ -n "$rvm_ruby_string" ]]; then
                rvm_ruby_args=("$rvm_ruby_string" "${rvm_ruby_args[@]}");
            fi;
            "${rvm_scripts_path}/$rvm_action" "$rvm_action" "${rvm_ruby_args[@]}"
        ;;
        export)
            __rvm_export "$rvm_export_args"
        ;;
        unexport)
            __rvm_unset_exports
        ;;
        error)
            false
        ;;
        which)
            __rvm_which "${rvm_ruby_args[@]}"
        ;;
        *)
            rvm_error "unknown action '$rvm_action'";
            false
        ;;
    esac;
    current_result=$?;
    (( result )) || result=${current_result};
    (( result )) || case "$rvm_action" in 
        reinstall | try_install | install)
            if [[ -n "${rvm_ruby_string}" ]];
            rvm_is_a_shell_function no_warning; then
                if [[ -e "${rvm_environments_path}/default" ]]; then
                    rvm_verbose_flag=0 __rvm_use;
                else
                    rvm_verbose_flag=0 rvm_default_flag=1 __rvm_use;
                fi;
            fi
        ;;
    esac;
    current_result=$?;
    (( result )) || result=${current_result};
    \typeset __local_rvm_trace_flag;
    __local_rvm_trace_flag=${rvm_trace_flag:-0};
    __rvm_cli_autoreload;
    if (( __local_rvm_trace_flag > 0 )); then
        set +o verbose;
        set +o xtrace;
        [[ -n "${ZSH_VERSION:-""}" ]] || set +o errtrace;
    fi;
    return ${result:-0}
}
rvm_debug () 
{ 
    (( ${rvm_debug_flag:-0} )) || return 0;
    if rvm_pretty_print stderr; then
        rvm_printf_to_stderr "%b" "${rvm_debug_clr:-}$*${rvm_reset_clr:-}\n";
    else
        rvm_printf_to_stderr "%b" "$*\n";
    fi
}
rvm_debug_stream () 
{ 
    if (( ${rvm_debug_flag:-0} == 0 && ${rvm_trace_flag:-0} == 0 )); then
        cat - > /dev/null;
    else
        if rvm_pretty_print stdout; then
            \command \cat - | __rvm_awk '{print "'"${rvm_debug_clr:-}"'"$0"'"${rvm_reset_clr:-}"'"}' 1>&6;
        else
            \command \cat - 1>&6;
        fi;
    fi
}
rvm_error () 
{ 
    if rvm_pretty_print stderr; then
        rvm_printf_to_stderr "%b" "${rvm_error_clr:-}$*${rvm_reset_clr:-}\n";
    else
        rvm_printf_to_stderr "%b" "$*\n";
    fi
}
rvm_error_help () 
{ 
    rvm_error "$1";
    shift;
    rvm_help "$@"
}
rvm_fail () 
{ 
    rvm_error "$1";
    exit "${2:-1}"
}
rvm_help () 
{ 
    "${rvm_scripts_path}/help" "$@"
}
rvm_install_gpg_setup () 
{ 
    { 
        rvm_gpg_command="$( \which gpg2 2>/dev/null )" && [[ ${rvm_gpg_command} != "/cygdrive/"* ]]
    } || { 
        rvm_gpg_command="$( \which gpg 2>/dev/null )" && [[ ${rvm_gpg_command} != "/cygdrive/"* ]]
    } || rvm_gpg_command="";
    rvm_debug "Detected GPG program: '$rvm_gpg_command'";
    [[ -n "$rvm_gpg_command" ]] || return $?
}
rvm_is_a_shell_function () 
{ 
    \typeset _message;
    if (( ${rvm_is_not_a_shell_function:-0} )) && [[ "${1:-}" != "no_warning" ]]; then
        if rvm_pretty_print stderr; then
            rvm_log "";
        fi;
        if rvm_pretty_print stderr; then
            rvm_error "${rvm_notify_clr:-}RVM is not a function, selecting rubies with '${rvm_error_clr:-}rvm use ...${rvm_notify_clr:-}' will not work.";
        else
            rvm_error "RVM is not a function, selecting rubies with 'rvm use ...' will not work.";
        fi;
        if [[ -n "${SUDO_USER:-}" ]]; then
            rvm_warn '
Please avoid using "sudo" in front of "rvm".
RVM knows when to use "sudo" and will use it only when it is necessary.
';
        else
            rvm_warn '
You need to change your terminal emulator preferences to allow login shell.
Sometimes it is required to use `/bin/bash --login` as the command.
Please visit https://rvm.io/integration/gnome-terminal/ for an example.
';
        fi;
    fi;
    return ${rvm_is_not_a_shell_function:-0}
}
rvm_log () 
{ 
    [[ ${rvm_quiet_flag} == 1 ]] && return;
    if rvm_pretty_print stdout; then
        printf "%b" "${rvm_notify_clr:-}$*${rvm_reset_clr:-}\n";
    else
        printf "%b" "$*\n";
    fi
}
rvm_out () 
{ 
    printf "$*\n"
}
rvm_pretty_print () 
{ 
    case "${rvm_pretty_print_flag:=auto}" in 
        0 | no)
            return 1
        ;;
        1 | auto)
            case "${TERM:-dumb}" in 
                dumb | unknown)
                    return 1
                ;;
            esac;
            case "$1" in 
                stdout)
                    [[ -t 1 ]] || return 1
                ;;
                stderr)
                    [[ -t 2 ]] || return 1
                ;;
                [0-9])
                    [[ -t $1 ]] || return 1
                ;;
                any)
                    [[ -t 1 || -t 2 ]] || return 1
                ;;
                *)
                    [[ -t 1 && -t 2 ]] || return 1
                ;;
            esac;
            return 0
        ;;
        2 | force)
            return 0
        ;;
    esac
}
rvm_printf_to_stderr () 
{ 
    printf "$@" 1>&6
}
rvm_verbose_log () 
{ 
    if (( ${rvm_verbose_flag:=0} == 1 )); then
        rvm_log "$@";
    fi
}
rvm_warn () 
{ 
    if rvm_pretty_print stdout; then
        rvm_printf_to_stderr "%b" "${rvm_warn_clr:-}$*${rvm_reset_clr:-}\n";
    else
        rvm_printf_to_stderr "%b" "$*\n";
    fi
}
shell_session_delete_expired () 
{ 
    if ( [ ! -e "$SHELL_SESSION_TIMESTAMP_FILE" ] || [ -z "$(find "$SHELL_SESSION_TIMESTAMP_FILE" -mtime -1d)" ] ); then
        local expiration_lock_file="$SHELL_SESSION_DIR/_expiration_lockfile";
        if shlock -f "$expiration_lock_file" -p $$; then
            echo -n 'Deleting expired sessions...';
            local delete_count=$(find "$SHELL_SESSION_DIR" -type f -mtime +2w -print -delete | wc -l);
            [ "$delete_count" -gt 0 ] && echo $delete_count' completed.' || echo 'none found.';
            ( umask 077;
            touch "$SHELL_SESSION_TIMESTAMP_FILE" );
            rm "$expiration_lock_file";
        fi;
    fi
}
shell_session_history_allowed () 
{ 
    if [ -n "$HISTFILE" ]; then
        local allowed=0;
        if shopt -q histappend || [ -n "$HISTTIMEFORMAT" ]; then
            allowed=${SHELL_SESSION_HISTORY:-0};
        else
            allowed=${SHELL_SESSION_HISTORY:=1};
        fi;
        if [ $allowed -eq 1 ]; then
            return 0;
        fi;
    fi;
    return 1
}
shell_session_history_check () 
{ 
    if [ ${SHELL_SESSION_DID_HISTORY_CHECK:-0} -eq 0 ]; then
        SHELL_SESSION_DID_HISTORY_CHECK=1;
        if shell_session_history_allowed; then
            shell_session_history_enable;
        fi;
        if [ "$PROMPT_COMMAND" = "shell_session_history_check" ]; then
            unset PROMPT_COMMAND;
        else
            if [[ $PROMPT_COMMAND =~ (.*)(; *shell_session_history_check *| *shell_session_history_check *; *)(.*) ]]; then
                PROMPT_COMMAND="${BASH_REMATCH[1]}${BASH_REMATCH[3]}";
            fi;
        fi;
    fi
}
shell_session_history_enable () 
{ 
    ( umask 077;
    touch "$SHELL_SESSION_HISTFILE_NEW" );
    HISTFILE="$SHELL_SESSION_HISTFILE_NEW";
    SHELL_SESSION_HISTORY=1
}
shell_session_save () 
{ 
    if [ -n "$SHELL_SESSION_FILE" ]; then
        echo -n 'Saving session...';
        ( umask 077;
        echo 'echo Restored session: "$(date -r '$(date +%s)')"' >|"$SHELL_SESSION_FILE" );
        declare -F shell_session_save_user_state > /dev/null && shell_session_save_user_state;
        shell_session_history_allowed && shell_session_save_history;
        echo 'completed.';
    fi
}
shell_session_save_history () 
{ 
    shell_session_history_enable;
    history -a;
    if [ -f "$SHELL_SESSION_HISTFILE_SHARED" ] && [ ! -s "$SHELL_SESSION_HISTFILE" ]; then
        echo -ne '\n...copying shared history...';
        ( umask 077;
        cp "$SHELL_SESSION_HISTFILE_SHARED" "$SHELL_SESSION_HISTFILE" );
    fi;
    echo -ne '\n...saving history...';
    ( umask 077;
    cat "$SHELL_SESSION_HISTFILE_NEW" >> "$SHELL_SESSION_HISTFILE_SHARED" );
    ( umask 077;
    cat "$SHELL_SESSION_HISTFILE_NEW" >> "$SHELL_SESSION_HISTFILE" );
    : >|"$SHELL_SESSION_HISTFILE_NEW";
    if [ -n "$HISTFILESIZE" ]; then
        echo -n 'truncating history files...';
        HISTFILE="$SHELL_SESSION_HISTFILE_SHARED";
        HISTFILESIZE="$HISTFILESIZE";
        HISTFILE="$SHELL_SESSION_HISTFILE";
        HISTFILESIZE="$size";
        HISTFILE="$SHELL_SESSION_HISTFILE_NEW";
    fi;
    echo -ne '\n...'
}
shell_session_update () 
{ 
    shell_session_save && shell_session_delete_expired
}
update_terminal_cwd () 
{ 
    local url_path='';
    { 
        local i ch hexch LC_CTYPE=C LC_ALL=;
        for ((i = 0; i < ${#PWD}; ++i))
        do
            ch="${PWD:i:1}";
            if [[ "$ch" =~ [/._~A-Za-z0-9-] ]]; then
                url_path+="$ch";
            else
                printf -v hexch "%02X" "'$ch";
                url_path+="%${hexch: -2:2}";
            fi;
        done
    };
    printf '\e]7;%s\a' "file://$HOSTNAME$url_path"
}
verify_package_pgp () 
{ 
    if "${rvm_gpg_command}" --verify "$2" "$1"; then
        rvm_log "GPG verified '$1'";
    else
        \typeset _ret=$?;
        rvm_error "Warning, RVM 1.26.0 introduces signed releases and automated check of signatures when GPG software found. Assuming you trust Michal Papis import the mpapis public key (downloading the signatures).

GPG signature verification failed for '$1' - '$3'! Try to install GPG v2 and then fetch the public key:

    ${SUDO_USER:+sudo }gpg2 --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3

or if it fails:

    command curl -sSL https://rvm.io/mpapis.asc | ${SUDO_USER:+sudo }${rvm_gpg_command##*/} --import -

the key can be compared with:

    https://rvm.io/mpapis.asc
    https://keybase.io/mpapis

NOTE: GPG version 2.1.17 have a bug which cause failures during fetching keys from remote server. Please downgrade or upgrade to newer version (if available) or use the second method described above.
";
        return _ret;
    fi
}
